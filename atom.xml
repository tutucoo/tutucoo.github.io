<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打渔为生</title>
  
  <subtitle>tutucoo的技术笔记</subtitle>
  <link href="https://tutucoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://tutucoo.github.io/"/>
  <updated>2022-02-12T07:46:48.528Z</updated>
  <id>https://tutucoo.github.io/</id>
  
  <author>
    <name>tutucoo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>trace技术@trace非标准算法</title>
    <link href="https://tutucoo.github.io/2022/02/12/trace%E6%8A%80%E6%9C%AF@trace%E9%9D%9E%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/12/trace%E6%8A%80%E6%9C%AF@trace%E9%9D%9E%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-12T03:03:37.000Z</published>
    <updated>2022-02-12T07:46:48.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="trace非标准算法"><a href="#trace非标准算法" class="headerlink" title="trace非标准算法"></a>trace非标准算法</h1><p>如果目标sign加密采用了非标准算法，通过采用trace的方式进行算法还原</p><p>动态调试目标，利用IDA脚本可以对目标的so文件进行trace</p><p>trace过程中会碰到很多系统库的的函数，脚本对地址进行了判断，如果不是在目标so文件中的地址则不进行trace</p><p><img src="https://s2.loli.net/2022/02/12/b14JWzcaYry2gt7.png" alt="image-20220212110435364"></p><p>这里指定一下so的名称以及指定函数的起始地址和结束地址</p><p><img src="https://s2.loli.net/2022/02/12/jExiZ8uA2XTJINM.png" alt="Untitled"></p><p>IDA中进行动态调试，在算法函数断下后，执行trace脚本，如果此时程序有多个线程，要把其他线程挂起，防止反调试，之后要再执行resume_process()恢复进程</p><p><img src="https://s2.loli.net/2022/02/12/7RpBxdYLoa8jE5M.png" alt="Untitled"></p><p>用IDA进行trace过程中，会产生trace日志，使用命令tail -f xxx.log可以动态看trace的日志有没有增加</p><p><img src="https://s2.loli.net/2022/02/12/4lmzfbJpEYuswCt.png" alt="Untitled"></p><p>trace有两种方法：</p><p>1、直接在trace日志里面搜索加密后的数据，然后向前推算出算法</p><p>2、从加密函数开始处逆向出算法</p><p>先使用第2种方法，trace完之后找到函数开始的位置</p><p><img src="https://s2.loli.net/2022/02/12/23deRlYWAjgipkL.png" alt="Untitled"></p><p>向上搜索找到两个参数，第一个参数是随机值，第二个参数是长度</p><p><img src="https://s2.loli.net/2022/02/12/Mk9eOCFG7rXR5tl.png" alt="Untitled"></p><p>搜x0的值，发现x9这里使用了</p><p><img src="https://s2.loli.net/2022/02/12/aLvF1z7p3BZuoWb.png" alt="Untitled"></p><p>再继续找x9，发现这里进行load，0x66其实就是f，也就是随机字符串的第一个字符</p><p><img src="https://s2.loli.net/2022/02/12/soN9TI5ubztamxp.png" alt="Untitled"></p><p>因为这个地址+5f0的位置保存了随机字符串，那么trace时这个地址应该会保存字符串中的所有字符，全局搜一下，发现果然是随机字符串</p><p><img src="https://s2.loli.net/2022/02/12/5VPqnu9I1sicKFU.png" alt="image-20220212154637486"></p><p>再看第二个字符，000000725eb3f1b0是第一个字符，x9的值是000000725eb3f1b1也就是第2个字符</p><p><img src="https://s2.loli.net/2022/02/12/QEkNzD8y4TgtR6n.png" alt="Untitled"></p><p>再往上看x9是哪里来的，可以看到是x0+1得来的，x9是1</p><p><img src="https://s2.loli.net/2022/02/12/vScQUGqM8WyZto6.png" alt="Untitled"></p><p>继续搜这个地址</p><p><img src="https://s2.loli.net/2022/02/12/fxNbJol3IjW6qky.png" alt="Untitled"></p><p>这里b7过后直接是b9，也就是说字符串下标为8的位置有特殊处理 </p><p><img src="https://s2.loli.net/2022/02/12/vETx2tISjMfwyuz.png" alt="Untitled"></p><p>对比下输入和输出，可以看到第9位是一个横杠符号</p><p><img src="https://s2.loli.net/2022/02/12/odmM6yRE52Ih1un.png" alt="Untitled"></p><p>搜一下b8</p><p><img src="https://s2.loli.net/2022/02/12/yg258n6OtDwqobr.png" alt="Untitled"></p><p>b8被加载到x9，然后w23存到x9，x23的值是2d，也就是“-”</p><p><img src="https://s2.loli.net/2022/02/12/mXeDPEgzMU92FBR.png" alt="Untitled"></p><p>下标为8、下标为d的位置都是直接被-替换，但是到了fUC2就不一样了，替换成了4UC2</p><p><img src="https://s2.loli.net/2022/02/12/JzwE7XWLk1PpKog.png" alt="Untitled"></p><p>先把前两个-替换掉，再分析后面的算法</p><p><img src="https://s2.loli.net/2022/02/12/f3hLQJSlGXKTYOC.png" alt="Untitled"></p><p>4UC2的4位置下标为e，通过下图中的地址，可以看到分别对每个下标字符进行了处理，而e并不存在</p><p><img src="https://s2.loli.net/2022/02/12/ViBZWsagd74oEPN.png" alt="Untitled"></p><p>单独搜一下e</p><p><img src="https://s2.loli.net/2022/02/12/S81ntr9RubqTAiL.png" alt="Untitled"></p><p>这里把w23存到x9位置，w23的值就是4</p><p><img src="https://s2.loli.net/2022/02/12/wNgL3UZzI9yocK4.png" alt="Untitled"></p><p>看一下多次的结果，这个位置每一个都是4，说明是写死的 </p><p><img src="https://s2.loli.net/2022/02/12/X2qxnO79AGF8ET5.png" alt="Untitled"></p><p>所以把这个位置填充为4</p><p><img src="https://s2.loli.net/2022/02/12/Am5oeDhVKpTPCrn.png" alt="Untitled"></p><p>然后再看后面的，同样也是被替换成了-号，它的位置是2</p><p><img src="https://s2.loli.net/2022/02/12/cHFjESWs5dLGrRT.png" alt="Untitled"></p><p>所以单独搜一下它的地址，发现确实被替换成了-号 </p><p><img src="https://s2.loli.net/2022/02/12/hNFBI4unPyarHY6.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/12/IVZOXrBymfapGPv.png" alt="Untitled"></p><p>所以这个位置也赋值为-</p><p><img src="https://s2.loli.net/2022/02/12/QTXUy6nrE5Ajboi.png" alt="Untitled"></p><p>接下来到了7这个位置又不一样了，变成了Seq</p><p><img src="https://s2.loli.net/2022/02/12/319ZmNfIlixq8JA.png" alt="Untitled"></p><p>还是搜字符所在的地址，看下c7的位置的值是怎么来的 </p><p><img src="https://s2.loli.net/2022/02/12/4QRKsxmYLl2paUn.png" alt="Untitled"></p><p>单独搜一下这个值</p><p><img src="https://s2.loli.net/2022/02/12/zikgx6Pw2sjq39v.png" alt="Untitled"></p><p>这个值是从c7拿出来的，它保存的值是0x71，也就是q</p><p><img src="https://s2.loli.net/2022/02/12/VAfPjpGckvhSX1s.png" alt="Untitled"></p><p>看一下这个值0x71是哪里来的，这个地址的引用有好几处，看下293行</p><p><img src="https://s2.loli.net/2022/02/12/JltcoAfGIHyiaOK.png" alt="Untitled"></p><p>可以看到值来自[sp,#0xc]</p><p><img src="https://s2.loli.net/2022/02/12/48R12iQ3kAK9dNe.png" alt="Untitled"></p><p>往上找[sp,#0xc]</p><p><img src="https://s2.loli.net/2022/02/12/h1a3MgXpvSs25Bq.png" alt="Untitled"></p><p>可以看到w28的值存到[sp,#0xc]中了，w28的值来自于[x0,#0x18]，</p><p><img src="https://s2.loli.net/2022/02/12/rlGBTwoOVhRQb6I.png" alt="Untitled"></p><p>x0+0x18实际上就是输入字符串的下标</p><p><img src="https://s2.loli.net/2022/02/12/Zv51S7ieCdFnM8p.png" alt="Untitled"></p><p>这个算法就是这样，输入字符串下标18的位置给输出字符串17的位置，原位置由-代替</p><p><img src="https://s2.loli.net/2022/02/12/sdpCcSluGzYRDvJ.png" alt="Untitled"></p><p>然后再看最后两位不一样的</p><p><img src="https://s2.loli.net/2022/02/12/743F8HTlUgRprzP.png" alt="Untitled"></p><p>最后的2个地址看一下它的值</p><p><img src="https://s2.loli.net/2022/02/12/FP9dgJlVuCZ3rMn.png" alt="Untitled"></p><p>d0的值是31，d1的值是75，对应1u，所以现在要找最后两位</p><p><img src="https://s2.loli.net/2022/02/12/pkeh6mfnxZqKMuP.png" alt="Untitled"></p><p>搜索d2，但是没有结果，说明它并没有读取输入字符串这个位置的值 </p><p><img src="https://s2.loli.net/2022/02/12/BeKVv12iJpHzUDT.png" alt="Untitled"></p><p>看下输入的引用，可以看到最后2个位置它直接写进去了 </p><p><img src="https://s2.loli.net/2022/02/12/OtubxYCGB6PmoK8.png" alt="Untitled"></p><p>可以看到是赋值给了输入字符串</p><p>之前分析过输入字符串的地址赋值给了x0</p><p><img src="https://s2.loli.net/2022/02/12/ywA5dJtO1KUIWHV.png" alt="Untitled"></p><p>要想找到最后两位，一定是对x0的某个偏移进行赋值，搜过x0=搜不到结果，可以搜索[x0,</p><p>下图对0x23偏移进行赋值，也就是下标35的位置赋值为0x34，也就是4</p><p><img src="https://s2.loli.net/2022/02/12/mG6IknpMfPNdT5H.png" alt="Untitled"></p><p>下标34的位置也找到了，赋值为0x62，也就是b</p><p><img src="https://s2.loli.net/2022/02/12/4Zk1wibxRLNOaBG.png" alt="Untitled"></p><p>赋值的位置找到了，还要找到这两个值的来源</p><p>先看最后一个，它的值来自地址x8，x8的值是c28c</p><p><img src="https://s2.loli.net/2022/02/12/1KlWNqGETjoihm4.png" alt="Untitled"></p><p>因为x8是一个指针所以判断它是一个数组</p><p><img src="https://s2.loli.net/2022/02/12/9qHXNwJELSoIFPn.png" alt="Untitled"></p><p>看下这个地址被赋值的情况，x9+x23的结果就是c28c，x23的值是0x4</p><p><img src="https://s2.loli.net/2022/02/12/Z84xwekqH25soyO.png" alt="Untitled"></p><p>继续看x9的来源，来自c000</p><p><img src="https://s2.loli.net/2022/02/12/rxsIZPmp7BGtF3e.png" alt="Untitled"></p><p>搜c000，但是只有这个结果</p><p><img src="https://s2.loli.net/2022/02/12/iMXfy4FchstudZN.png" alt="image-20220212111120937"></p><p>这里卡住了，就直接搜0x34</p><p>这里搜索的时候可以用正则表达式</p><p><img src="https://s2.loli.net/2022/02/12/76V1ILPBXHgRhmw.png" alt="Untitled"></p><p>0x34前面加4个点，这样包含0x34的也可以搜到，但是还是搜不到什么</p><p><img src="https://s2.loli.net/2022/02/12/Pi9EMtaW5s1LDHb.png" alt="image-20220212111153857"></p><p>静态看下这里 </p><p><img src="https://s2.loli.net/2022/02/12/UeAPcY9fJaoIq3p.png" alt="Untitled"></p><p>看下v14的引用</p><p><img src="https://s2.loli.net/2022/02/12/2IpacPR4Z9NWgjz.png" alt="Untitled"></p><p>v14从一个字符串中拿一个字符作为值 </p><p><img src="https://s2.loli.net/2022/02/12/EMOTFoj254vDkRG.png" alt="Untitled"></p><p>找到c70地址引用了它 </p><p><img src="https://s2.loli.net/2022/02/12/XowB2Njn5ZcKq6T.png" alt="Untitled"></p><p>然后在trace日志里找到了对应的位置，所以0x71cc20c000就是字符串的地址 </p><p><img src="https://s2.loli.net/2022/02/12/yUgS8eTFl2xk4tR.png" alt="Untitled"></p><p>然后0xc000+0x288，最后+0x4，在字符串对应数字4</p><p><img src="https://s2.loli.net/2022/02/12/uVMzx2N45rYnJbe.png" alt="Untitled"></p><p>0x4来自[sp,#0x18]</p><p><img src="https://s2.loli.net/2022/02/12/HsC8DpzngNWASuP.png" alt="Untitled"></p><p>它的值从w23传进来的</p><p><img src="https://s2.loli.net/2022/02/12/mo34iREeqrUVStZ.png" alt="Untitled"></p><p>w23是通过w23&amp;0xf得到的,x23的值是0x94，也就是0x94&amp;0xf</p><p>w23是从[sp,#0x64]来的</p><p><img src="https://s2.loli.net/2022/02/12/BT8wJ614zMhupjq.png" alt="Untitled"></p><p>搜索到上一次出现[sp,#0x64]的地方，数据来自w1，而w1的值就是0x94</p><p><img src="https://s2.loli.net/2022/02/12/j2scl49ztV81HmQ.png" alt="Untitled"></p><p>w1又来自于w4，w4是w4跟w9异或的结果 </p><p><img src="https://s2.loli.net/2022/02/12/47MjJnDokhLvTrl.png" alt="Untitled"></p><p>w4的值是0x75，w9的值是0xe1，0x75的值来自于输入字符串</p><p><img src="https://s2.loli.net/2022/02/12/P2ECYHrvo8MAs7V.png" alt="Untitled"></p><p>搜一下这行，发现这个地址都是异或</p><p><img src="https://s2.loli.net/2022/02/12/v3hfOXks4aEbByP.png" alt="Untitled"></p><p>看到了e1的值，是由D0跟31进行异或，31也是来自于源字符串</p><p><img src="https://s2.loli.net/2022/02/12/nCeBslKFiP4q8EN.png" alt="Untitled"></p><p>d0的值来自6d和bd的异或，6d也是来自源字符串</p><p><img src="https://s2.loli.net/2022/02/12/DScOKsbEYTmJ653.png" alt="Untitled"></p><p>这就发现了一个规律，异或的其中一个值都来自源字符串，而另一个值是上一个值异或的结果</p><p><img src="https://s2.loli.net/2022/02/12/5TbqKrhSRF4QUsV.png" alt="Untitled"></p><p>对比一下源字符串，确实一致</p><p><img src="https://s2.loli.net/2022/02/12/J2PIn5hYERSAB3f.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/12/64iLzKt8WyM1fuw.png" alt="Untitled"></p><p>写算法测试一下，在循环中进行异或</p><p><img src="https://s2.loli.net/2022/02/12/KbFVfJwv25e7Plq.png" alt="Untitled"></p><p>这里的值还不一样，初始值其实是0xff</p><p><img src="https://s2.loli.net/2022/02/12/SOGTMr9u4d6b8ya.png" alt="Untitled"></p><p>这个结果就正确了</p><p><img src="https://s2.loli.net/2022/02/12/RkncgCFrBKJVM4I.png" alt="Untitled"></p><p>但是到了d5后面结果就不对了</p><p><img src="https://s2.loli.net/2022/02/12/nkrHPecSAbjJXim.png" alt="Untitled"></p><p>打印一下下标，下标18的位置就不一样了，说明可能是下标17的位置有问题，因为下标17进行了单独的处理</p><p><img src="https://s2.loli.net/2022/02/12/kJfRCBnDtoI3uLG.png" alt="Untitled"></p><p>下标17的单独处理 </p><p><img src="https://s2.loli.net/2022/02/12/7gYUG4tQV9826L1.png" alt="Untitled"></p><p>而算法这时候对下标17的位置也进行了处理，所以要再处理一次 </p><p><img src="https://s2.loli.net/2022/02/12/M4nBzSZ9HK3AID5.png" alt="Untitled"></p><p>修改过后就正确了，不过a4后面又有个位置不一样了 </p><p><img src="https://s2.loli.net/2022/02/12/vYGst8KXphQk5DJ.png" alt="Untitled"></p><p>看下a4，其实是跟0x79进行异或</p><p><img src="https://s2.loli.net/2022/02/12/vE7rUYsxeRSKFza.png" alt="Untitled"></p><p>0x79在源字符串中的位置就是0x18</p><p><img src="https://s2.loli.net/2022/02/12/4Qw9MmT7txlRNZi.png" alt="Untitled"></p><p>其实0x18的位置是-，所以要用-替换</p><p><img src="https://s2.loli.net/2022/02/12/gQOmqjY8ti1sKSG.png" alt="Untitled"></p><p>下标35是与0xf进行异或，看下下标34的值是0x62</p><p><img src="https://s2.loli.net/2022/02/12/AJcLeZ6BkSofUPm.png" alt="Untitled"></p><p>0x62的值来自于下标为b的位置</p><p><img src="https://s2.loli.net/2022/02/12/9WAB3XZmb8wCYus.png" alt="Untitled"></p><p>它存在下面的字符串中</p><p><img src="https://s2.loli.net/2022/02/12/UMNYjgZbVOKk7Ph.png" alt="Untitled"></p><p>经过追踪0x22的算法如下</p><p><img src="https://s2.loli.net/2022/02/12/cROyFhjtmIUBSWi.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/12/4NSZYpInKgTl5aq.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;trace非标准算法&quot;&gt;&lt;a href=&quot;#trace非标准算法&quot; class=&quot;headerlink&quot; title=&quot;trace非标准算法&quot;&gt;&lt;/a&gt;trace非标准算法&lt;/h1&gt;&lt;p&gt;如果目标sign加密采用了非标准算法，通过采用trace的方式进行算法还原&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@汇编代码审计还原ollvm字符串加密</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86/</id>
    <published>2022-02-11T09:16:37.000Z</published>
    <updated>2022-02-11T09:17:31.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编代码审计还原ollvm字符串加密"><a href="#汇编代码审计还原ollvm字符串加密" class="headerlink" title="汇编代码审计还原ollvm字符串加密"></a>汇编代码审计还原ollvm字符串加密</h1><p>这个例子在搜索.datadiv时没有结果，这是因为修改了默认的ollvm前缀，可以通过查看.init_array段，找到解密字符串函数 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211u9fTFB.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled.png"></p><p>像下图中veorq_s8这种字符串加密，一般只在64位中才有，32位的没有</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211v2WmvM.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%201.png"></p><p>这里使用了stru_37010的两个字节</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bQgdpk.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%202.png"></p><p>它在文件中的偏移是0x36010</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211BxEWYX.png" alt="image-20220211171710509"></p><p>找到它的位置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NVTQts.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%204.png"></p><p>选中十六个字节拷贝</p><p><img src="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%205.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%205.png"></p><p>这十六个字节跟v0进行异或，v0是0xc6</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211RvfJ75.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%206.png"></p><p>在010中进行异或操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wnrH9g.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%207.png"></p><p>解密后看到这个字符串的值是Hello from JNI</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nGGGcw.png" alt="%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%2014db95f1df144032b242e029ecf69f01/Untitled%208.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇编代码审计还原ollvm字符串加密&quot;&gt;&lt;a href=&quot;#汇编代码审计还原ollvm字符串加密&quot; class=&quot;headerlink&quot; title=&quot;汇编代码审计还原ollvm字符串加密&quot;&gt;&lt;/a&gt;汇编代码审计还原ollvm字符串加密&lt;/h1&gt;&lt;p&gt;这个例子在搜</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@通过frida inline hook还原ollvm字符串混淆</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86/</id>
    <published>2022-02-11T09:10:37.000Z</published>
    <updated>2022-02-11T09:12:43.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过frida-inline-hook还原ollvm字符串混淆"><a href="#通过frida-inline-hook还原ollvm字符串混淆" class="headerlink" title="通过frida inline hook还原ollvm字符串混淆"></a>通过frida inline hook还原ollvm字符串混淆</h1><p>还是在init_array段里，发现有几个函数，进去看一下</p><p><img src="https://s2.loli.net/2022/02/11/EjZhxfoHm98pFSa.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled.png"></p><p>发现这些都不是解密字符串的函数 </p><p><img src="https://s2.loli.net/2022/02/11/9gmLi4ShtQ1RjJT.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%201.png"></p><p>在JNI_Onload中给参数转类型JavaVM*会出现bug，需要指定jni头文件，7.0以后会自动解析</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211j1klBV.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%202.png"></p><p>进入JNI_OnLoad函数，看到数组偏移v9是被xmmword_3E1E8赋值的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211erhr3N.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%203.png"></p><p>向上回溯，找到数组偏移的最终来源dword_3E1B4</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111p4kan.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%204.png"></p><p>再对它进行转码，转为ngis，这就是函数的名字sign的倒序字母</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211coVaLi.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%205.png"></p><p>xmmword_3e1e8跟dword_3e184是一样的，所以下面的是对参数的赋值 ，v6就是参数，而v6又是byte_3e1ba赋值的，byte_3e1ba的值来自byte_22e80，这个值就是函数的参数</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NMTrVg.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%206.png"></p><p>hook byte_3e1ba的值，发现它也是一个字符串 </p><p>看下byte_22e80的值 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211kpbmfx.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%207.png"></p><p>byte_22e80的值赋值给byte_3e195</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211WUUPGZ.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%208.png"></p><p>为了知道RegisterNatives函数传递的参数的具体内容，对RegisterNatives函数进行hook</p><p>每个参数大小是8个字节，因为是64位系统</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202112ZHfj7.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%209.png"></p><p>动态注册的函数名是sign1，返回值是一个字符串，也就是说只要能hook到RegisterNatives函数就能找到动态注册的函数名</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116dseOl.png" alt="Untitled"></p><p>如果碰到一种情况，无法找到RegisterNatives函数的地址，就比较麻烦了</p><p>我们可以查看byte_22e80的反汇编 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211rEHoXG.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%2011.png"></p><p>731c进行了异或，可以hook 7320，就可以解密的字符串了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tnM0Yp.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%2012.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inline_hook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_hello_jni = Module.findBaseAddress(<span class="string">&quot;libhello-jni.so&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(base_hello_jni);</span><br><span class="line">    <span class="keyword">if</span>(base_hello_jni)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(base_hello_jni);</span><br><span class="line">        <span class="keyword">var</span> addr_07320 = base_hello_jni.add(<span class="number">0x07320</span>);</span><br><span class="line">        <span class="comment">// inline hook 和 hook函数是一样的</span></span><br><span class="line">        Interceptor.attach(addr_07320,&#123;</span><br><span class="line">            onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 64位: X0-X30, XZR(零寄存器)   要学汇编! 不然没法玩inline hook</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;addr_07320 x13&quot;</span>,<span class="built_in">this</span>.context.x13, <span class="string">&quot; x14&quot;</span>,<span class="built_in">this</span>.context.x14);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会发现没法hook成功，是因为frida注入脚本的时候，我们要hook的so文件还没加载。这时候我们需要来hook dlopen,dlopen加载成功以后在去执行inline_hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * dlopen（<span class="keyword">const</span> char * filename ，int flag ）;</span><br></pre></td></tr></table></figure><p>dlopen有2个参数, 我们打印第一个 filename</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_dlopen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dlopen = Module.findExportByName(<span class="literal">null</span>,<span class="string">&quot;dlopen&quot;</span>);</span><br><span class="line">    Interceptor.attach(dlopen,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;dlopen&quot;</span>,ptr(args[<span class="number">0</span>]).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现没有我们需要的.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Pixel <span class="number">2</span>::com.example.hellojni_sign2]-&gt; dlopen /vendor/lib64/egl/libGLESv2_adreno.so</span><br><span class="line">dlopen /vendor/lib64/egl/libEGL_adreno.so   </span><br><span class="line">dlopen /vendor/lib64/egl/libGLESv2_adreno.so</span><br><span class="line">dlopen /system/lib64/libEGL.so</span><br><span class="line">dlopen /system/lib64/libGLESv2.so</span><br><span class="line">dlopen /system/lib64/libGLESv1_CM.so</span><br><span class="line">dlopen /vendor/lib64/egl/eglSubDriverAndroid.so</span><br><span class="line">dlopen libadreno_utils.so</span><br><span class="line">dlopen /vendor/lib64/egl/libEGL_adreno.so</span><br></pre></td></tr></table></figure><p>在android6.0的时候,hookdlopen的时候是可以加载所有的so的,但是在高版本的时候就没有了, 我们需要hook另外一个函数,叫做android_dlopen_ext, 所以我们去hook他</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_dlopen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dlopen = Module.findExportByName(<span class="literal">null</span>,<span class="string">&quot;dlopen&quot;</span>);</span><br><span class="line">    Interceptor.attach(dlopen,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;dlopen&quot;</span>,ptr(args[<span class="number">0</span>]).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = Module.findExportByName(<span class="literal">null</span>,<span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    Interceptor.attach(android_dlopen_ext,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;android_dlopen_ext&quot;</span>,ptr(args[<span class="number">0</span>]).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果, 我们可以看到libhello-jni.so 那么此时就可以去hook他了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Spawned <span class="string">`com.example.hellojni_sign2`</span>. Resuming main thread!</span><br><span class="line">[Pixel <span class="number">2</span>::com.example.hellojni_sign2]-&gt; android_dlopen_ext /data/app/com.example.hellojni_sign2-VfsaSmMy0zmiYY_Le5Ylfw==<span class="regexp">/oat/</span>arm64/base.odex</span><br><span class="line">android_dlopen_ext /vendor/lib64/egl/libEGL_adreno.so</span><br><span class="line">dlopen /vendor/lib64/egl/libGLESv2_adreno.so</span><br><span class="line">android_dlopen_ext /data/app/com.example.hellojni_sign2-VfsaSmMy0zmiYY_Le5Ylfw==<span class="regexp">/lib/</span>arm64/libhello-jni.so</span><br><span class="line">dlopen /vendor/lib64/egl/libEGL_adreno.so</span><br><span class="line">android_dlopen_ext /vendor/lib64/egl/libGLESv1_CM_adreno.so</span><br><span class="line">dlopen /vendor/lib64/egl/libGLESv2_adreno.so</span><br><span class="line">android_dlopen_ext /vendor/lib64/egl/libGLESv2_adreno.so</span><br><span class="line">dlopen /system/lib64/libEGL.so</span><br><span class="line">dlopen /system/lib64/libGLESv2.so</span><br><span class="line">dlopen /system/lib64/libGLESv1_CM.so</span><br><span class="line">dlopen /vendor/lib64/egl/eglSubDriverAndroid.so</span><br><span class="line">android_dlopen_ext /vendor/lib64/hw/gralloc.msm8998.so</span><br><span class="line">dlopen libadreno_utils.so</span><br><span class="line">dlopen /vendor/lib64/egl/libEGL_adreno.so</span><br><span class="line">android_dlopen_ext /vendor/lib64/hw/android.hardware.graphics.mapper@<span class="number">2.0</span>-impl.so</span><br><span class="line">android_dlopen_ext /vendor/lib64/hw/gralloc.msm8998.so</span><br></pre></td></tr></table></figure><p>然后再修改下代码,整体代码大概如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inline_hook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base_hello_jni = Module.findBaseAddress(<span class="string">&quot;libhello-jni.so&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(base_hello_jni);</span><br><span class="line">    <span class="keyword">if</span>(base_hello_jni)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;base_hello_jni&quot;</span>,base_hello_jni);</span><br><span class="line">        <span class="keyword">var</span> addr_07320 = base_hello_jni.add(<span class="number">0x07320</span>);</span><br><span class="line">        <span class="comment">// inline hook 和 hook函数是一样的</span></span><br><span class="line">        Interceptor.attach(addr_07320,&#123;</span><br><span class="line">            onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// 根据反汇编值保存在W13，在ARM64里面x13的第8位是W13</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;addr_07320 x13&quot;</span>,<span class="built_in">this</span>.context.x13);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> is_hook_hello_jni = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_dlopen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = Module.findExportByName(<span class="literal">null</span>,<span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    Interceptor.attach(android_dlopen_ext,&#123;</span><br><span class="line">        onEnter:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> so_name = ptr(args[<span class="number">0</span>]).readCString();</span><br><span class="line">            <span class="keyword">if</span>(so_name.indexOf(<span class="string">&quot;libhello-jni.so&quot;</span>))&#123;</span><br><span class="line">                is_hook_hello_jni = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;android_dlopen_ext&quot;</span>,so_name);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_hook_hello_jni)&#123;</span><br><span class="line">                inline_hook()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ns7UMD.png" alt="Untitled"></p><p>再把x13的值放到010editor中查看.就可以看到签名了.</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VGOj2I.png" alt="%E9%80%9A%E8%BF%87frida%20inline%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86%202294b779590f423ea72d4d4df0268c01/Untitled%2014.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过frida-inline-hook还原ollvm字符串混淆&quot;&gt;&lt;a href=&quot;#通过frida-inline-hook还原ollvm字符串混淆&quot; class=&quot;headerlink&quot; title=&quot;通过frida inline hook还原ollvm字符串混</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@通过frida hook还原ollvm字符串加密</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86/</id>
    <published>2022-02-11T08:49:37.000Z</published>
    <updated>2022-02-11T08:50:17.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过frida-hook还原ollvm字符串加密"><a href="#通过frida-hook还原ollvm字符串加密" class="headerlink" title="通过frida hook还原ollvm字符串加密"></a>通过frida hook还原ollvm字符串加密</h1><p>app在OnCreate中调用了jni函数sign1</p><p><img src="https://s2.loli.net/2022/02/11/GgLPTd9fQvVqpjB.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled.png"></p><p>在字符串窗口可以搜索到.datadiv前缀的字符串，这是默认的ollvm混淆字符串的函数 </p><p><img src="https://s2.loli.net/2022/02/11/IQAmT5Zut3jwJoU.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled%201.png"></p><p>进入这个函数可以看到字符串都被混淆了</p><p><img src="https://s2.loli.net/2022/02/11/XFUN6lWK4Ov1DJx.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled%202.png"></p><p>以异或0xD2为例, 在010Editor的工具中可以恢复这个字符串，十六进制计算中存在异或选项. 无符号字节,十六进制，此时就可以拿到解密以后的结果</p><p>ollvm静态的时候没法看到明文字符串，执行以后在.init_array函数里面对字符串进行解密，解密之后内存之中的字符串就是明文字符串了</p><p>JNI_OnLoad函数的函数数组偏移是这样的</p><p><img src="https://s2.loli.net/2022/02/11/EeolH3gBxqhCJWP.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled%203.png"></p><p>转换指针，可以看到函数，不过函数名被混淆了成了aYcmd</p><p><img src="https://s2.loli.net/2022/02/11/oCiv1DerfkcUQ8d.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled%204.png"></p><p>通过frida hook可以打印出真正的函数名，执行下面的脚本，aYcmd解密后还原了明文sign1 </p><p>通过这种方式可以还原所有的字符串，只不过工作量会很大</p><p><img src="https://s2.loli.net/2022/02/11/BFlJuG1cPg2Zf6o.png" alt="%E9%80%9A%E8%BF%87frida%20hook%E8%BF%98%E5%8E%9Follvm%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%205c6fc7e7648b438bb22a21f93c41641f/Untitled%205.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过frida-hook还原ollvm字符串加密&quot;&gt;&lt;a href=&quot;#通过frida-hook还原ollvm字符串加密&quot; class=&quot;headerlink&quot; title=&quot;通过frida hook还原ollvm字符串加密&quot;&gt;&lt;/a&gt;通过frida hook还原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@frida辅助分析ollvm虚假控制流</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
    <published>2022-02-11T08:34:37.000Z</published>
    <updated>2022-02-11T08:40:36.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="frida辅助分析ollvm虚假控制流"><a href="#frida辅助分析ollvm虚假控制流" class="headerlink" title="frida辅助分析ollvm虚假控制流"></a>frida辅助分析ollvm虚假控制流</h1><p>虚假控制流混淆跟指令替换不一样的地方是，指令替换每一个函数块都特别的长，而虚假控制流有很多的x和y，这些都是全局变量</p><p><img src="https://s2.loli.net/2022/02/11/Zud1ip7enVKAozq.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled.png"></p><p>会通过这些全局变量来进行判断,哪些函数会被执行，虚假的不会被执行</p><p><img src="https://s2.loli.net/2022/02/11/xJYTN4ASKcvXwCs.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%201.png"></p><p>这些全局变量可以通过导出函数看到</p><p><img src="https://s2.loli.net/2022/02/11/monj4py6wKSBDQk.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%202.png"></p><p>没有返回值的是虚假控制流，不会被调用</p><p><img src="https://s2.loli.net/2022/02/11/KmD3XRQTkCxwvLr.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%203.png"></p><p>str1在GetStringUTFChars处引用，返回值v10传递给了sub_12b44函数</p><p><img src="https://s2.loli.net/2022/02/11/VcCGQyh8ODtTYaK.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%204.png"></p><p>hook sub_12b44函数 </p><p>参数1是返回值的，在onLeave中打印</p><p><img src="https://s2.loli.net/2022/02/11/bAFgDZpXvmQzxqU.png" alt="Untitled"></p><p>sub_12b44函数调用了多次</p><p><img src="https://s2.loli.net/2022/02/11/JlUOIkhtNjSFf7Z.png" alt="Untitled"></p><p>修改脚本，调用时打印第2个参数，onLeave时打印第1个参数</p><p><img src="https://s2.loli.net/2022/02/11/IkKlG9LtvQbXm13.png" alt="Untitled"></p><p>前面2次分别是传递了str1和str2，第3次是盐字符串</p><p><img src="https://s2.loli.net/2022/02/11/YuwE9Ap7gt6zdGo.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%208.png"></p><p>接着往下看，sub_12b44调用多次</p><p><img src="https://s2.loli.net/2022/02/11/q8XYEKVFwb32vn7.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%209.png"></p><p>然后调用sub_1391c，str1和str2给了v26和v27，传出来的东西给了sub_18ab0</p><p><img src="https://s2.loli.net/2022/02/11/xoaXtmbLBc9WUAC.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2010.png"></p><p>先hook sub_1391c</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_1391C = base_hello_jni.add(<span class="number">0x1391c</span>);</span><br><span class="line">Interceptor.attach(sub_1391C, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1391C onEnter:&quot;</span>,hexdump(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,hexdump(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1391C onLeave:&quot;</span>,hexdump(retval),<span class="string">&quot;\r\n&quot;</span>,hexdump(<span class="built_in">this</span>.arg0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在函数调用时，参数1是导出的，没什么有用的，参数2是str1，函数执行完之后参数1的值跟str1是一样的了</p><p><img src="https://s2.loli.net/2022/02/11/tZP1bQyB9u8CEHM.png" alt="Untitled"></p><p>接着hook sub_18ab0，它有两个参数都是导出的</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_18AB0 = base_hello_jni.add(<span class="number">0x18AB0</span>);</span><br><span class="line">Interceptor.attach(sub_18AB0, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onEnter:&quot;</span>,hexdump(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,hexdump(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(retval));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第一个参数是str1，第二个参数是str2,</p><p><img src="https://s2.loli.net/2022/02/11/8XY1GeltgywWT6z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2012.png"></p><p>返回值跟最终的加密字符串还是不太一样，最终字符串是a2c78374514d…</p><p><img src="https://s2.loli.net/2022/02/11/fkdNescCq9XL7S6.png" alt="Untitled"></p><p>返回值看起来像是2个指针，打印出来看一下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_18AB0 = base_hello_jni.add(<span class="number">0x18AB0</span>);</span><br><span class="line">Interceptor.attach(sub_18AB0, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.arg1 = args[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onEnter:&quot;</span>,hexdump(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,hexdump(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(retval));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(retval.readPointer()));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(retval.add(Process.pointerSize).readPointer()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还是看不出来跟最终的加密字符串有相关</p><p><img src="https://s2.loli.net/2022/02/11/xlJWtdRaXh4VZUD.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2014.png"></p><p>但是sub_18ab0函数传递了两个字符串，它后面调用的函数都只传了一个参数，所以还是继续看这个函数</p><p>看下sub_18ab0的反汇编，x1和x0是传递的两个参数，返回值给了x0，但是这里x0是没有用的，这里可以看到x8，x8在arm64里面比较特殊，当返回值的内容大于16个字节时使用x8保存返回内容的地址</p><p><img src="https://s2.loli.net/2022/02/11/8bLmpnfEktXisqU.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2015.png"></p><p>打印一下x8的值  </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_18AB0 = base_hello_jni.add(<span class="number">0x18AB0</span>);</span><br><span class="line">Interceptor.attach(sub_18AB0, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.arg1 = args[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.arg8 = <span class="built_in">this</span>.context.x8;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onEnter:&quot;</span>,hexdump(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,hexdump(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(<span class="built_in">this</span>.arg8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>31是buffer，20是长度，0x74ce6853是一个地址</p><p><img src="https://s2.loli.net/2022/02/11/1o9XVIRsDNepBMg.png" alt="Untitled"></p><p>打印下0x74ce6853地址看一下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_18AB0 = base_hello_jni.add(<span class="number">0x18AB0</span>);</span><br><span class="line">Interceptor.attach(sub_18AB0, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.arg1 = args[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.arg8 = <span class="built_in">this</span>.context.x8;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onEnter:&quot;</span>,hexdump(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,hexdump(args[<span class="number">1</span>]));</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(<span class="built_in">this</span>.arg8));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_18AB0 onLeave:&quot;</span>,hexdump(ptr(<span class="built_in">this</span>.arg8).add(Process.pointerSize * <span class="number">2</span>).readPointer()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这时可以看到返回值就是最终加密的字符串了，所以sub_18ab0就是核心的算法函数了</p><p><img src="https://s2.loli.net/2022/02/11/tdsq3GXe4npY7IA.png" alt="Untitled"></p><p>进入函数看一下参数引用，发现都不存在引用</p><p><img src="https://s2.loli.net/2022/02/11/AjZG9Q5IadDzWN8.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2018.png"></p><p>看下反汇编，因为x8保存了最终的加密字符串，所以重点看下x8，x8赋值给了x19</p><p><img src="https://s2.loli.net/2022/02/11/g3laiAUvbkXSFex.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2019.png"></p><p>这里x19赋值给了x0,</p><p><img src="https://s2.loli.net/2022/02/11/gkfmprRJ2O15tNI.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2020.png"></p><p>hook sub_19248，打印x0、w2、x1三个参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_19248 = base_hello_jni.add(<span class="number">0x19248</span>);</span><br><span class="line">Interceptor.attach(sub_19248, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_19248 onEnter:&quot;</span>,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>]);</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_19248 onLeave:&quot;</span>,retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参数输入了两个地址，返回的也是一个地址</p><p><img src="https://s2.loli.net/2022/02/11/SXrUOpHJWcsTw2z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2021.png"></p><p>dump看一下 ，发现第2个参数就是最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/uCfcVF43KRWI597.png" alt="Untitled"></p><p>var_70保存了最终加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/lxNnrOG3PaAqVRT.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2023.png"></p><p>f5一下，看到v11来自v13，v13来自于sub_16900函数</p><p><img src="https://s2.loli.net/2022/02/11/lKuyDg3XnFp7SJr.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2024.png"></p><p>hook sub_16900函数，它有3个参数，前面2个是输入，第3个参数是输出，所以也要在函数执行完之后打印一下 </p><p><img src="https://s2.loli.net/2022/02/11/qlZ8MGictgT1A4I.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2025.png"></p><p>第3个参数保存的是最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/wJ2RyCq9VZgjb4X.png" alt="Untitled"></p><p>看下sub_16900的算法</p><p><img src="https://s2.loli.net/2022/02/11/bS7OVlyRK9BoGrP.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2027.png"></p><p>再进入sub_16530看一下 ，通过之前hook sub_16900可以得知参数的内容，修改一下参数名</p><p><img src="https://s2.loli.net/2022/02/11/AeNvC5G1luq9DmR.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2028.png"></p><p>查看out_buffer引用</p><p><img src="https://s2.loli.net/2022/02/11/P1uUFBXsqil7OfK.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2029.png"></p><p>看一下sub_16214函数，out_buffer给了v3</p><p><img src="https://s2.loli.net/2022/02/11/TAJP5fiWScazDnl.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2030.png"></p><p>可以看到后面把v4的一部分值给了v3</p><p><img src="https://s2.loli.net/2022/02/11/5Bsuw7qVbzyvgQk.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2031.png"></p><p>sub_15fac引用了v4，所以看一下这个函数 </p><p>result的值赋值给了v5</p><p><img src="https://s2.loli.net/2022/02/11/jXSncJfdDBezZEN.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2032.png"></p><p>下面调用了函数sub_1531c并传入了v5</p><p><img src="https://s2.loli.net/2022/02/11/sx7UTuNcrLA4af9.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2033.png"></p><p>进入sub_1531c，可以看到算法，搜一下发现是md5编码</p><p><img src="https://s2.loli.net/2022/02/11/rLJOnkbB4vFZuM1.png" alt="Untitled"></p><p>hook sub_1531c的上层函数sub_15fac</p><p><img src="https://s2.loli.net/2022/02/11/d6uIEstewmY8K3O.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2035.png"></p><p>hook 第2个参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_15FAC = base_hello_jni.add(<span class="number">0x15FAC</span>);</span><br><span class="line">Interceptor.attach(sub_15FAC, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_15FAC onEnter:&quot;</span>,ptr(args[<span class="number">1</span>]).readCString());</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>sub_15fac调用了4次，第2个参数是salt字符串</p><p><img src="https://s2.loli.net/2022/02/11/KTWUys7HC8q3mNd.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2036.png"></p><p>算法总结：</p><p>1、多次调用sub_15fac拼接salt字符串</p><p>2、md5编码</p><p><img src="https://s2.loli.net/2022/02/11/cEpv8rQLiTFRusW.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E8%99%9A%E5%81%87%E6%8E%A7%E5%88%B6%E6%B5%81%2062dae712e1fb4047898e83766fe1e3dd/Untitled%2037.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;frida辅助分析ollvm虚假控制流&quot;&gt;&lt;a href=&quot;#frida辅助分析ollvm虚假控制流&quot; class=&quot;headerlink&quot; title=&quot;frida辅助分析ollvm虚假控制流&quot;&gt;&lt;/a&gt;frida辅助分析ollvm虚假控制流&lt;/h1&gt;&lt;p&gt;虚假</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@frida辅助分析ollvm指令替换</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/</id>
    <published>2022-02-11T08:20:37.000Z</published>
    <updated>2022-02-11T08:27:21.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="frida辅助分析ollvm指令替换"><a href="#frida辅助分析ollvm指令替换" class="headerlink" title="frida辅助分析ollvm指令替换"></a>frida辅助分析ollvm指令替换</h1><p>jni加密算法sign2</p><p><img src="https://s2.loli.net/2022/02/11/K5Cus7PxkzdYXpm.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled.png"></p><p>主动调用sign2</p><p><img src="https://s2.loli.net/2022/02/11/UKeEO2unG1h9APZ.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%201.png"></p><p>返回的sign有时候一样，有时候不一样</p><p><img src="https://s2.loli.net/2022/02/11/WI1N3XhPkjO9iTx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%202.png"></p><p>f5失败，可以加载jni.h文件，也可以通过加载类型库的方式解决</p><p><img src="https://s2.loli.net/2022/02/11/E9GrhMvBXCJ8iyj.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%203.png"></p><p><img src="https://s2.loli.net/2022/02/11/cUnvW25NksMAF8y.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%204.png"></p><p>看下JNIEnv的引用，v7改为_env</p><p><img src="https://s2.loli.net/2022/02/11/21drWsl6wkOSeZV.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%205.png"></p><p>接着hook sign2函数，看下GetStringUTFChars的参数</p><p><img src="https://s2.loli.net/2022/02/11/1UWB5nFedkamghG.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%206.png"></p><p>sign2的参数和返回值都打印出来了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sign2 str1: <span class="number">0123456789</span></span><br><span class="line">sign2 str2: abcdefg</span><br><span class="line">sign2 retval: a2c78374514d7934432cbc66cd1e293b</span><br></pre></td></tr></table></figure><p>先从sign2函数的str1参数开始分析，看到两处引用，赋值给了v5</p><p><img src="https://s2.loli.net/2022/02/11/5QNzY7VDJ6naWrl.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%207.png"></p><p>将v5改名为str_1_1，v8改为c_str_1</p><p>看下str_1_1的引用，发现是调用ReleaseStringUTFChars函数时使用的，所以接着看c_str_1</p><p><img src="https://s2.loli.net/2022/02/11/RicCdrHoIyUeJ2z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%208.png"></p><p>看下c_str_1的引用，调用了memcpy，赋值给了v11</p><p><img src="https://s2.loli.net/2022/02/11/U2vNXmsfREOeYMu.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%209.png"></p><p>v11引用，v11在c_str_1赋值后，后续没有再使用，所以分析v161</p><p><img src="https://s2.loli.net/2022/02/11/4sFvcwoZ7CK6L8H.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2010.png"></p><p>v161引用，203行之前的先不看，先看后面的</p><p>v161赋值给了v75，v75不是一个指针，先不看</p><p><img src="https://s2.loli.net/2022/02/11/H6iNjOlMJgcsYq3.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2011.png"></p><p>v161赋值给了v154，然后跳转到了LABEL_22</p><p><img src="https://s2.loli.net/2022/02/11/uA5etRabYTDKj6w.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2012.png"></p><p>看下v154的引用，看下sub_1DFB4</p><p><img src="https://s2.loli.net/2022/02/11/d8WbRYEt2qDulBN.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2013.png"></p><p>hook sub_1dfb4</p><p><img src="https://s2.loli.net/2022/02/11/AwVSPUHagrMEvq5.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2014.png"></p><p>sub_1dfb4的两个参数和返回值，看起来像个地址</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_1DFB4 <span class="number">0x74b5cc6b90</span> <span class="number">0x74b5cc6b70</span></span><br><span class="line">sub_1DFB4 onLeave <span class="number">0x74ce6855d0</span></span><br></pre></td></tr></table></figure><p>dump这些地址的内容</p><p><img src="https://s2.loli.net/2022/02/11/ZqhBs7lVrexo25P.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2015.png"></p><p>sub_1dfb4的第一个参数和第二个参数是传递进来的str1和str2</p><p><img src="https://s2.loli.net/2022/02/11/Tq23yM1pLzJsjow.png" alt="Untitled"></p><p>函数执行完返回的值是加密的，可以看出虽然sub_1dfb4反编译的时候没有返回值，但其实有返回值的 </p><p>可以看到sub_1dfb4的返回值跟最终的加密sign是一致的</p><p><img src="https://s2.loli.net/2022/02/11/MtIaiN7rZXojcBG.png" alt="Untitled"></p><p>在sub_1dfb4上面，有一堆指令替换的操作，本来很简单的指令弄的很复杂，这些都不用看，直接进入sub_1dfb4进行分析</p><p><img src="https://s2.loli.net/2022/02/11/H9ljMOKx5Z7BN1E.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2018.png"></p><p>进入sub_1dfb4，参数又变成了一个，这个不用管，在函数名上面右键Set item type，可以设置多个参数以及类型</p><p><img src="https://s2.loli.net/2022/02/11/ZutN4j13favW27H.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2019.png"></p><p><img src="https://s2.loli.net/2022/02/11/NwCoJOb6ETB9vFI.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2020.png"></p><p>查找两个参数的引用，发现是空</p><p>查看反汇编，并没有看到参数的痕迹，x0和x1并没有被使用，但是调用了sub_1e298，可能参数会直接传递到这个函数里面</p><p><img src="https://s2.loli.net/2022/02/11/DfRI9dp6mx5ao4b.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2021.png"></p><p>hook sub_1e298</p><p><img src="https://s2.loli.net/2022/02/11/Tbz8lNcCBxRSq4D.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2022.png"></p><p>可以看到sub_1e298的参数就是str1和str2</p><p><img src="https://s2.loli.net/2022/02/11/AhwTKHvEGo4JlaO.png" alt="Untitled"></p><p>先看一下参数1的引用，它的值给了v16和v17</p><p><img src="https://s2.loli.net/2022/02/11/ZD5tJH4u7oeEbSn.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2024.png"></p><p>然后看v16的引用，没有什么有价值的</p><p><img src="https://s2.loli.net/2022/02/11/dTwn7iFW8DY6lUG.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2025.png"></p><p>再看v17的引用，可以看到v17赋值给了v20</p><p><img src="https://s2.loli.net/2022/02/11/mjJLDFRNlokCzBi.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2026.png"></p><p>v20之前的值来自v28或者v5</p><p><img src="https://s2.loli.net/2022/02/11/dUghjsp4R8xGq6z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2027.png"></p><p>先看下v28，v28没有什么东西，看下v5</p><p><img src="https://s2.loli.net/2022/02/11/ApdaMqnIEsbiwHt.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2028.png"></p><p>v5里面调用了一个函数</p><p><img src="https://s2.loli.net/2022/02/11/hmFaoCpOwlMnJVU.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2029.png"></p><p>可以看到v5两处调用，因为sub_1ab0上面调用了memcpy，把str1赋值给了v20，所以下面要对sub_1ab50进行hook，看str1有没有传递</p><p><img src="https://s2.loli.net/2022/02/11/JW63tRalKoe8bQx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2030.png"></p><p>hook它的三个参数和返回值 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_1AB50 = base_hello_jni.add(<span class="number">0x1AB50</span>);</span><br><span class="line">Interceptor.attach(sub_1AB50, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB50 onEnter:&quot;</span>,(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,(args[<span class="number">1</span>]),args[<span class="number">2</span>]);</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB50 onLeave:&quot;</span>,retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两次调用了sub_1ab50，参数1和参数2是个指针，参数3应该是个长度</p><p><img src="https://s2.loli.net/2022/02/11/j6OxaL3FZy8cGYW.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2031.png"></p><p>dump一下地址，可以看到这个函数返回的内容</p><p><img src="https://s2.loli.net/2022/02/11/qoyu3d6Qc7pfHSA.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2032.png"></p><p>第二次调用是传递的加盐字符串</p><p><img src="https://s2.loli.net/2022/02/11/vwJWDUOt6rAeFZq.png" alt="Untitled"></p><p>返回了加盐拼接字符串</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++++++salt2+</span><br></pre></td></tr></table></figure><p>所以可以认为sub_1ab50函数的功能主要是拼接字符串的</p><p>hook sub_1e298的返回值</p><p><img src="https://s2.loli.net/2022/02/11/k3SlnwJTLrOjhER.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2034.png"></p><p>可以看到也是返回的拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/rUYjIcRuTX5hHEl.png" alt="Untitled"></p><p>看下sub_1e298的返回值X0，虽然X0没有被使用，不过下面调用了sub_1ab4c</p><p><img src="https://s2.loli.net/2022/02/11/oynZ59Ae8vO6rUx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2036.png"></p><p>反编译没有返回值，但是有三个参数，其中最后一个是返回值 </p><p><img src="https://s2.loli.net/2022/02/11/OURi9KlhWwLkIYm.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2037.png"></p><p>hook sub_1ab4c</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_1AB4C = base_hello_jni.add(<span class="number">0x1AB4C</span>);</span><br><span class="line">Interceptor.attach(sub_1AB4C, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB4C onEnter:&quot;</span>,args[<span class="number">0</span>],(args[<span class="number">1</span>]),args[<span class="number">2</span>]);</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB4C onLeave:&quot;</span>,retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>hook结果 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub_1AB4C onEnter: <span class="number">0x74b5cc6ad9</span> <span class="number">0x11</span> <span class="number">0x74b5cc6b18</span></span><br><span class="line">sub_1AB4C onLeave: <span class="number">0x74b5cc6960</span></span><br><span class="line">sign2 retval: 43898b3fe54cfe43af19206c592acaf3</span><br></pre></td></tr></table></figure><p>sub_1ab4c第一个参数传递了拼接字符串，其他的参数和返回值没有有用的 </p><p><img src="https://s2.loli.net/2022/02/11/DRAHzrTn8ONkKLV.png" alt="Untitled"></p><p>因为它第三个参数可能是个返回值，所以函数执行完以后打印这个参数看下，可以看到这第三个参数确实就是最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/yckudsmgqaCvhVG.png" alt="Untitled"></p><p>sub_1ab4c就是核心的加密函数</p><p><img src="https://s2.loli.net/2022/02/11/SgvmrezJUEP2slM.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2040.png"></p><p>它的内部调用了sub_195bc</p><p><img src="https://s2.loli.net/2022/02/11/PzlEVZkbWm2d9OK.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2041.png"></p><p>首先看下input_buffer的引用</p><p><img src="https://s2.loli.net/2022/02/11/7YbPZSlhHdVxgnW.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2042.png"></p><p>v3改名为_input_buffer，再看_input_buffer的引用</p><p><img src="https://s2.loli.net/2022/02/11/Rmy56Pp7YbtIUcf.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2043.png"></p><p>hook sub_171c4函数，第1个参数有返回值 ，第2个参数是拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/EnyiVkFALfU7wI2.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2044.png"></p><p>看到都是指针，第一个参数跟返回值都是一样的地址</p><p><img src="https://s2.loli.net/2022/02/11/DGhjzkbv9l84Fm5.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2045.png"></p><p>hexdump看一下，第1个参数和返回值都是40，第2个参数是拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/RlkuUFdwyNVYc4p.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/wV6XWzrs3bnDB9M.png" alt="Untitled"></p><p>因为没有看到最终的加密字符串，进入sub_171c4函数看下</p><p>看到常量，搜索一下，搜索出来的结果显示这里是md5编码</p><p><img src="https://s2.loli.net/2022/02/11/VeCiOxslh6U5QPD.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2048.png"></p><p>可以看到对sub_171c4的第二个参数进行md5编码可以得到最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/tl1NOwTGkKH8BpL.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2049.png"></p><p>算法总结：</p><p>1、0123456789拼接abcdefg</p><p>2、添加盐</p><p>3、md5运算</p><p>之所以每次加密的字符串都不一样是因为盐字符串每次都会变化</p><p><img src="https://s2.loli.net/2022/02/11/fxDFlqsYpOjegrZ.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2050.png"></p><p>查找盐字符串生成的函数</p><p><img src="https://s2.loli.net/2022/02/11/aKIEpNzMdRvkbnV.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2051.png"></p><p>可以看到是sub_1ab50返回的 </p><p><img src="https://s2.loli.net/2022/02/11/s4FYB5foe1UOQJn.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2052.png"></p><p>sub_1ab50内部调用了随机函数生成随机的盐字符串</p><p><img src="https://s2.loli.net/2022/02/11/Z1DTWUwVEG6KceX.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2053.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;frida辅助分析ollvm指令替换&quot;&gt;&lt;a href=&quot;#frida辅助分析ollvm指令替换&quot; class=&quot;headerlink&quot; title=&quot;frida辅助分析ollvm指令替换&quot;&gt;&lt;/a&gt;frida辅助分析ollvm指令替换&lt;/h1&gt;&lt;p&gt;jni加密算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@分析ollvm混淆的iqiyi sign算法</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-11T08:04:37.000Z</published>
    <updated>2022-02-11T08:08:57.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析ollvm混淆的iqiyi-sign算法"><a href="#分析ollvm混淆的iqiyi-sign算法" class="headerlink" title="分析ollvm混淆的iqiyi sign算法"></a>分析ollvm混淆的iqiyi sign算法</h1><p>sign算法是getQdscJNI函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.qiyi;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protect</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getQdsc</span><span class="params">(Object obj, String str)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">return</span> getQdscJNI(obj, str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"> </span><br><span class="line">         &#125; <span class="keyword">catch</span> (UnsupportedEncodingException unused) &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// getQdsc内部调用的是native函数</span></span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getQdscJNI</span><span class="params">(Object obj, <span class="keyword">byte</span>[] bArr)</span></span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过 frida直接调用getQdsc函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">function <span class="title">call_getQdsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Java.perform(function () &#123;</span><br><span class="line">         <span class="keyword">var</span> currentApplication = Java.use(<span class="string">&quot;android.app.ActivityThread&quot;</span>).currentApplication();</span><br><span class="line">         <span class="keyword">var</span> context = currentApplication.getApplicationContext();</span><br><span class="line">         <span class="keyword">var</span> Protect = Java.use(<span class="string">&quot;com.qiyi.Protect&quot;</span>);</span><br><span class="line">         <span class="keyword">var</span> qdsc = Protect.getQdsc(context, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">         console.log(<span class="string">&quot;qdsc:&quot;</span>, qdsc);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> call_getQdsc()</span><br></pre></td></tr></table></figure><p>主动调用qdsc函数生成的字符串 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202118DpuVS.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled.png"></p><p>IDA加载<code>libprotect.so</code>，找到函数getQdscJNI</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111D0cUX.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%201.png"></p><p>先来看一个简单的ollvm 流程平坦化之后的流程图是怎么样的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bSPORR.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%202.png"></p><p>进入sub_126B4，看下整体流程图</p><p><img src="https://s2.loli.net/2022/02/11/GK3nHveY9Lq4w1o.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%203.png"></p><p>先来看看函数定义，由前面的调用参数可以知道a1是JNIEnv的指针，a3是一个char*的buffer，a4是buffer的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> unsigned int *__fastcall sub_126B4(JNIEnv *a1, int a2, char *buffer, int buffer_len)</span><br></pre></td></tr></table></figure><p>第一步找到buffer的交叉引用</p><p><img src="https://s2.loli.net/2022/02/11/wlBxLcZeGIdbkYf.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%204.png"></p><p>对v7 重命名为 buffer_1， 查看buffer_1的交叉引用，看到原始数据传入了sub_1189C</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cFW3Po.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%205.png"></p><p>查看sub_1189C</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> v70 &#x3D; (unsigned int *)sub_1189C(&amp;v103, buffer_1, v8);</span><br></pre></td></tr></table></figure><p>查看v8的引用,看到v8被参数buffLen赋值</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cnHYyc.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%206.png"></p><p>v8就是bufferLen， 对v8重命名为bufferLen_</p><p>sub_1189C 的后两个参数一个buffer, 一个是len, 因此先写一段frida脚本来hook sub_1189C函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> base_protect = Module.findBaseAddress(<span class="string">&quot;libprotect.so&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (base_protect) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;base_protect:&quot;</span>, base_protect);</span><br><span class="line">         <span class="keyword">var</span> sub_1189C = base_protect.add(<span class="number">0x1189C</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C:&quot;</span>, sub_1189C);</span><br><span class="line">         Interceptor.attach(sub_1189C, &#123;</span><br><span class="line">             onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">                 <span class="built_in">this</span>.buffer = args[<span class="number">1</span>];</span><br><span class="line">                 <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">2</span>]);</span><br><span class="line">                 <span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C onEnter:\n&quot;</span>, hexdump(<span class="built_in">this</span>.buffer, &#123; <span class="attr">length</span>: <span class="built_in">this</span>.len &#125;));</span><br><span class="line">             &#125;,</span><br><span class="line">             onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用call_getQdsc, 可以看到sub_1189C的参数buffer已经打印出来了，可以看到这时的buffer不再是123,而是aXFpqiyi.Protec=</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; hook_native()</span><br><span class="line"> </span><br><span class="line"> base_protect: 0xd0a64000</span><br><span class="line"> </span><br><span class="line"> sub_1189C: 0xd0a7589c</span><br><span class="line"> </span><br><span class="line"> undefined</span><br><span class="line"> </span><br><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; call_getQdsc()</span><br><span class="line"> </span><br><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c1505aa0 61 58 46 70 71 69 79 69 2e 50 72 6f 74 65 63 3d aXFpqiyi.Protec&#x3D;</span><br><span class="line"> </span><br><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> d160bd00 33 30 38 32 30 32 34 37 33 30 38 32 30 31 62 30 30820247308201b0</span><br><span class="line"> </span><br><span class="line"> d160bd10 61 30 30 33 30 32 30 31 30 32 30 32 30 34 34 63 a00302010202044c</span><br><span class="line"> </span><br><span class="line"> d160bd20 39 64 61 36 61 30 33 30 30 64 30 36 30 39 32 61 9da6a0300d06092a</span><br><span class="line"> </span><br><span class="line"> d160bd30 38 36 34 38 38 36 66 37 30 64 30 31 30 31 30 35 864886f70d010105</span><br><span class="line"> </span><br><span class="line"> d160bd40 30 35 30 30 33 30 36 37 33 31 30 62 33 30 30 39 05003067310b3009</span><br><span class="line"> </span><br><span class="line"> d160bd50 30 36 30 33 35 35 30 34 30 36 31 33 30 32 34 33 37af87</span><br><span class="line"> </span><br><span class="line"> qdsc: 616904a6660256fafef2db967eb82880</span><br></pre></td></tr></table></figure><p>补充一下，对sub_126b4进行hook，传进来123，123是怎么变成aXFpqiyi.Protec=的？</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yrQb2F.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%207.png"></p><p>暂时先不分析sub_1189C函数，先把sub_126B4的buffer参数引用分析完。</p><p>选择第三个引用</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pEvvbe.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%208.png"></p><p>再次查看ptr的交叉引用</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bN2xsK.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%209.png"></p><p>查看sub_11A68，两个参数一个buffer, 一个是len, 写一段frida脚本hook sub_11A68</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> sub_11A68 = base_protect.add(<span class="number">0x11A68</span>);</span><br><span class="line"> Interceptor.attach(sub_11A68, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.buffer = args[<span class="number">2</span>];</span><br><span class="line"> <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">3</span>]);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;sub_11A68 onEnter:\n&quot;</span>, ptr(<span class="built_in">this</span>.buffer).readCString(<span class="built_in">this</span>.len)); </span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>现在把引用buffer的几个函数都已经找到了，下面深入分析sub_1189C、sub_11A68这两个函数的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> _BYTE *__fastcall sub_1189C(int a1, char *a2, int a3)</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;省略部分变量定义代码</span><br><span class="line"> </span><br><span class="line"> v3 &#x3D; a1;</span><br><span class="line"> </span><br><span class="line"> v4 &#x3D; a3;</span><br><span class="line"> </span><br><span class="line"> v5 &#x3D; a2;</span><br><span class="line"> </span><br><span class="line"> v6 &#x3D; malloc(0x21u);</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr(v6, 33);</span><br><span class="line"> </span><br><span class="line"> v21 &#x3D; 1732584193;</span><br><span class="line"> </span><br><span class="line"> v22 &#x3D; 4023233417;</span><br><span class="line"> </span><br><span class="line"> v23 &#x3D; 2562383102;</span><br><span class="line"> </span><br><span class="line"> v24 &#x3D; 271733878;</span><br><span class="line"> </span><br><span class="line"> v25 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> v26 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> sub_11A68(v3, (int)&amp;v21, (int)v5, v4);</span><br><span class="line"> </span><br><span class="line"> v7 &#x3D; v25;</span><br><span class="line"> </span><br><span class="line"> v8 &#x3D; (v25 &gt;&gt; 3) &amp; 0x3F;</span><br><span class="line"> </span><br><span class="line"> *((_BYTE *)&amp;v27 + v8) &#x3D; 0x80u;</span><br><span class="line"> </span><br><span class="line"> v9 &#x3D; v8 ^ 0x3F;</span><br><span class="line"> </span><br><span class="line"> v10 &#x3D; (char *)&amp;v27 + v8 + 1;</span><br><span class="line"> </span><br><span class="line"> if ( v9 &gt; 7 )</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr(v10, v9 - 8);</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> else</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> v11 &#x3D; _aeabi_memclr(v10, v9);</span><br><span class="line"> </span><br><span class="line"> sub_11CAC(v11, &amp;v21, &amp;v27);</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr4((int)&amp;v27, 56);</span><br><span class="line"> </span><br><span class="line"> v7 &#x3D; v25;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> v28 &#x3D; v7;</span><br><span class="line"> </span><br><span class="line"> v29 &#x3D; v26;</span><br><span class="line"> </span><br><span class="line"> sub_11CAC(v26, &amp;v21, &amp;v27);</span><br><span class="line"> </span><br><span class="line"> v17 &#x3D; v21;</span><br><span class="line"> </span><br><span class="line"> v18 &#x3D; v22;</span><br><span class="line"> </span><br><span class="line"> v19 &#x3D; v23;</span><br><span class="line"> </span><br><span class="line"> v20 &#x3D; v24;</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr4((int)&amp;v21, 88);</span><br><span class="line"> </span><br><span class="line"> v12 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> do</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> v13 &#x3D; *((unsigned __int8 *)&amp;v17 + v12);</span><br><span class="line"> </span><br><span class="line"> v14 &#x3D; a0123456789abcd[v13 &gt;&gt; 4];</span><br><span class="line"> </span><br><span class="line"> LOBYTE(v13) &#x3D; a0123456789abcd[v13 &amp; 0xF];</span><br><span class="line"> </span><br><span class="line"> v6[2 * v12] &#x3D; v14;</span><br><span class="line"> </span><br><span class="line"> v15 &#x3D; (int)&amp;v6[2 * v12++];</span><br><span class="line"> </span><br><span class="line"> *(_BYTE *)(v15 + 1) &#x3D; v13;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> while ( v12 !&#x3D; 16 );</span><br><span class="line"> </span><br><span class="line"> result &#x3D; (_BYTE *)(_stack_chk_guard - v30);</span><br><span class="line"> </span><br><span class="line"> if ( _stack_chk_guard &#x3D;&#x3D; v30 )</span><br><span class="line"> </span><br><span class="line"> result &#x3D; v6;</span><br><span class="line"> </span><br><span class="line"> return result;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在算法分析过程中，首先看到类似第<code>37，38， 39，40行</code>这种的常量</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202112HYrSC.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2010.png"></p><p>如果你已经熟悉这个常量，就能猜到这个是什么算法，通过在算法文件中搜索67452301之后，发现md5, sha1都有<code>67452301, EFCDAB89, 98BADCFE, 10325476</code>这四个常量，而sha1多一个<code>C3D2E1F0</code></p><p>因此可以判断出<code>sub_1189C是一个与md5相关的函数</code></p><p>先对一些变量进行重命名</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hdK4LI.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2011.png"></p><p>进去 <code>sub_11A68</code> 看看</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mImKjZ.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2012.png"></p><p>sub_11A68函数里面对参数进行了一些计算，然后调用了sub_11CAC函数，在算法逆向过程中，遇到一些移位异或运算，先粗略看看，然后跳过，只有在算法还原的过程中才仔细分析这些运算</p><p>进去<code>sub_11CAC</code>看看</p><p><img src="https://s2.loli.net/2022/02/11/vakwigL45Z3uGzT.png" alt="image-20220211160742433"></p><p>把sub_11CAC函数中的用到常量与md5_process函数的常量比较发现，都是一样的。现在可以把sub_11CAC命名为md5_process了</p><p><img src="https://s2.loli.net/2022/02/11/dZwMuvA4RJHYtV8.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2014.png"></p><p>确定了md5_process函数之后，就可以确定它的上层函数sub_11A68为md5_update函数，</p><p>sub_11A68的上层函数sub_1189C这时候看起来就是一个md5函数的结构了</p><p><img src="https://s2.loli.net/2022/02/11/fW3Njx1TgYKbr6S.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2015.png"></p><p>frida打印出sub_1189C的返回值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> base_protect = Module.findBaseAddress(<span class="string">&quot;libprotect.so&quot;</span>);</span><br><span class="line"> <span class="keyword">var</span> sub_1189c = base_protect.add(<span class="number">0x1189c</span>); </span><br><span class="line"> Interceptor.attach(sub_1189c, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.buffer = args[<span class="number">1</span>];</span><br><span class="line"> <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sub_1189c onEnter:\n&quot;</span>, ptr(<span class="built_in">this</span>.buffer).readCString(<span class="built_in">this</span>.len));</span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C onLeave retval:\n&quot;</span>, hexdump(retval, &#123; <span class="attr">length</span>: <span class="number">0x20</span> &#125;));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>aXFpqiyi.Protec=经过md5变成25c11bfb902a449f8d636900a3405419</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c9463e48 61 58 46 70 71 69 79 69 2e 50 72 6f 74 65 63 3d aXFpqiyi.Protec&#x3D;</span><br><span class="line"> </span><br><span class="line"> sub_1189C onLeave retval:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c62dd318 32 35 63 31 31 62 66 62 39 30 32 61 34 34 39 66 25c11bfb902a449f</span><br><span class="line"> </span><br><span class="line"> c62dd328 38 64 36 33 36 39 30 30 61 33 34 30 35 34 31 39 8d636900a3405419</span><br></pre></td></tr></table></figure><p>看完1189c再通过buffer交叉引用找到ptr，再通过ptr的交叉引用找到md5_update，之前已经找到所有buffer引用的地方，一个是1189c，还有一个11a68，1189c已经分析完了，然后要接着向下分析</p><p>再来看看ptr的交叉引用，没看到引用的函数</p><p><img src="https://s2.loli.net/2022/02/11/KwsEAxG9bBJmOhX.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2016.png"></p><p>再看看v103和v104的交叉引用</p><p><img src="https://s2.loli.net/2022/02/11/XBmMD2HeIJ5LjTc.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2017.png"></p><p>进入sub_11B64函数看下</p><p><img src="https://s2.loli.net/2022/02/11/WM4IFirtgUTvR1w.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2018.png"></p><p>继续写frida脚本，hook sub_11B64</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> sub_11B64 = base_protect.add(<span class="number">0x11B64</span>);</span><br><span class="line"> Interceptor.attach(sub_11B64, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line"> <span class="built_in">this</span>.arg1 = args[<span class="number">1</span>];</span><br><span class="line"> <span class="built_in">this</span>.arg2 = args[<span class="number">2</span>];</span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;sub_11B64 onLeave:\n&quot;</span>, hexdump(<span class="built_in">this</span>.arg1, &#123; <span class="attr">length</span>: <span class="number">0x10</span> &#125;));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>可以看到sub_11B64的a2输出结果和Java层调用qdsc函数的结果一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; call_getQdsc()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> sub_11B64 onLeave:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> de51cab0 61 69 04 a6 66 02 56 fa fe f2 db 96 7e b8 28 80 ai..f.V.....~.(.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> qdsc: 616904a6660256fafef2db967eb82880</span><br></pre></td></tr></table></figure><p>此时已经分析出结果</p><p><img src="https://s2.loli.net/2022/02/11/ECkLdVFwunUj4yZ.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2019.png"></p><p>通过hook sub_11a68 也就是md5_update，可以看到多次调用sub_11a68</p><p><img src="https://s2.loli.net/2022/02/11/TDrpVws3auCkge9.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2020.png"></p><p>qdsc = md5(str + “0n9wdzm8pcyl1obxe0n9qdzm2pcyf1ob”);</p><p>分析被Olllvm混淆的算法的时候，如果IDA能够F5反编译出来，那么按下面的思路来分析算法:</p><p>从参数找交叉引用，通过frida hook使用参数的地方(函数)。</p><p>如果还没分析出算法，再从结果找交叉引用，用frida hook返回结果的地方(函数)进行分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析ollvm混淆的iqiyi-sign算法&quot;&gt;&lt;a href=&quot;#分析ollvm混淆的iqiyi-sign算法&quot; class=&quot;headerlink&quot; title=&quot;分析ollvm混淆的iqiyi sign算法&quot;&gt;&lt;/a&gt;分析ollvm混淆的iqiyi sign</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@编写字符串混淆pass</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass/</id>
    <published>2022-02-11T07:41:37.000Z</published>
    <updated>2022-02-11T07:46:36.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写字符串混淆pass"><a href="#编写字符串混淆pass" class="headerlink" title="编写字符串混淆pass"></a>编写字符串混淆pass</h1><p>字符串混淆pass原理是编译时先混淆，使用前再解混淆</p><p>创建一个StringObf.h</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211u9bAJE.png" alt="Untitled"></p><p>创建一个StringObf.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cddyjm.png" alt="Untitled"></p><p>加入到CMakeLists.txt中 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211h9JTf7.png" alt="Untitled"></p><p>在Entry.cpp中添加StringObf.h并绑定变量</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202110OUQqd.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VQnUNH.png" alt="Untitled"></p><p>此时编译一下项目应该是编译成功的</p><p>创建一个测试文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211z5pPsa.png" alt="Untitled"></p><p>声明环境变量，使用clang编译测试文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fNsMj4.png" alt="Untitled"></p><p>测试文件的IR代码</p><p>@是全局变量的标识</p><p>%是局部的寄存器</p><p>可以看到这个例子里有全局的str，也有%str</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IRyjxY.png" alt="Untitled"></p><p>我们可以先对字符串进行逐位异或加密，再在使用前进行解密</p><p>要先进行加密就要对字符串进行赋值</p><p>写一个测试语句</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211jkm2k7.png" alt="Untitled"></p><p>看下IR中间代码，这里将y保存到下标arrayidx处，arrayidx来自%0的第0个，%0来自字符串数组</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HbZSon.png" alt="Untitled"></p><p>在StringObf.cpp中添加如下代码，先枚举所有基本块，再枚举所有指令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021130sfGH.png" alt="Untitled"></p><p>执行编译，生成pass，使用这个pass编译测试文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -load -Xclang /home/OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -strobf hello_ollvm_7.c -emit-llvm -S -o hello_ollvm_strobf.ll</span><br></pre></td></tr></table></figure><p>指令会在控制台中被打印出来 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202114XfcV3.png" alt="image-20220211154531275"></p><p>打印出每条指令之后再拿到指令里面的值，我们的目标是找@str，所以过滤str字符串</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211XHsbo5.png" alt="Untitled"></p><p>判断是否是一个全局变量，如果是全局变量可以通过判断进入内部逻辑，要找的就是全局变量@str</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211t28aSm.png" alt="Untitled"></p><p>找到全局str，获取到它的值 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211K6WNns.png" alt="image-20220211154546242"></p><p>接着获取到一个异或的值对字符串进行加密 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GDpjny.png" alt="Untitled"></p><p>接着要进行解密，进行解密需要先申请一个数组，为了了解llvm里面的数组是如何申请的，先在源码里申请一个数组然后进行编译看IR指令 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202112Uyic0.png" alt="Untitled"></p><p>alloca[7*i8]里面的7是数组的长度，先创建了一个数组，再通过bitcast拿到它的指针，这个bitcast就是llvm的函数 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211JBz0dT.png" alt="Untitled"></p><p>用AllocaInst创建一个数组，数组的名字随便拼接一个就可以，最后一个参数是插入当前指令之前</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211urQ7Xg.png" alt="Untitled"></p><p>如果不会使用可以在llvm项目里面搜关键字看下用法</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202113grx7e.png" alt="Untitled"></p><p>创建数组在IR指令中是这样的，发现指令不对，还差一个对齐，这样就需要找到AllocaInst另一个API</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zK5VKv.png" alt="Untitled"></p><p>至于有哪些API，在编写代码中点击进行看头文件直接可以看到</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202119OALXV.png" alt="Untitled"></p><p>添加对齐参数，并且使用数组ArrayType</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211o9xO1l.png" alt="Untitled"></p><p>这个时候创建成功</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b34qvc.png" alt="Untitled"></p><p>api使用方法有以下几种：</p><p>1、可以通过在编写源码的时候跳转看api</p><p>2、可以在llvm项目里面搜索关键字看看llvm是怎么用的</p><p>3、llvm官方文档查看使用方法</p><p>接着拿到数组的指针</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202115IR8Vo.png" alt="Untitled"></p><p>再获得字符串数组里面每个下标指针</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117kyNFj.png" alt="Untitled"></p><p>需要注意要调用insertBefore，否则这里就是反顺序的 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111h8Lmn.png" alt="Untitled"></p><p>再添加一个逻辑，把字符串数据保存到刚才创建的数组里 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Zl0wdf.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nVZ5sz.png" alt="Untitled"></p><p>可以把指令的值全部用%.str.bitcast代替</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wBgiXS.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Bneknu.png" alt="Untitled"></p><p>代替前</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211A2dTVe.png" alt="Untitled"></p><p>代替后</p><p><img src="%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass%20752ec966d0804194a1abb60834323e3c/Untitled%2032.png" alt="Untitled"></p><p>再加入异或的代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ze6xXj.png" alt="Untitled"></p><p>异或后进行保存</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fXDxHq.png" alt="Untitled"></p><p>要提前保存下异或的key </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211slc3Ze.png" alt="Untitled"></p><p>在使用前进行解密</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116m1D3F.png" alt="Untitled"></p><p>可以看到每次在存储前进行异或解密，这里的xor的key是10进制的98</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cAHdiK.png" alt="image-20220211154614212"></p><p>这样就无法看到原字符串的值，但是这样的静态反混淆是不够的，完全可以对这些字符进行解密，直接进行异或计算就可以得到原来的字符串</p><p>在优化编译的时候也是可以直接还原的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IuUmt4.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nidHiZ.png" alt="Untitled"></p><p>为了防止被优化，需要创建个变量进行中转</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211e1DN1D.png" alt="Untitled"></p><p>将把key保存到另一个变量，再取出，最后使用这个变量进行操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202110YHyqK.png" alt="Untitled"></p><p>可以看到这里是对%0进行操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111AppLq.png" alt="image-20220211154627516"></p><p>平坦化结合字符串加密</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tGnOXT.png" alt="Untitled"></p><p>虽然这样增加了逆向的难度，这里的字符串也被分割成了字符，而且无法一眼看出原字符串</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gL1tIF.png" alt="Untitled"></p><p>在汇编视图可以看到xor指令，这样还是可以还原字符串，只是过程比较繁琐 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211rq4cms.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写字符串混淆pass&quot;&gt;&lt;a href=&quot;#编写字符串混淆pass&quot; class=&quot;headerlink&quot; title=&quot;编写字符串混淆pass&quot;&gt;&lt;/a&gt;编写字符串混淆pass&lt;/h1&gt;&lt;p&gt;字符串混淆pass原理是编译时先混淆，使用前再解混淆&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@函数名加密pass</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86pass/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86pass/</id>
    <published>2022-02-11T07:40:37.000Z</published>
    <updated>2022-02-11T07:40:53.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数名加密pass"><a href="#函数名加密pass" class="headerlink" title="函数名加密pass"></a>函数名加密pass</h1><p>在Transforms下面创建EncodeFunctionName目录，创建一个EncodeFunctionName.cpp文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211iOaOmt.png" alt="Untitled"></p><p>创建下图中的几个文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IaLr3T.png" alt="Untitled"></p><p>Reload CMake Project</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211OiWHES.png" alt="Untitled"></p><p>把新创建的pass添加到Transforms目录下的CMakeLists.txt文件中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gBp2w7.png" alt="Untitled"></p><p>然后在EncodeFunctionName.cpp中添加头文件和命名空间</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211uj4gYq.png" alt="Untitled"></p><p>然后根据官方文档把下面的代码添加上去</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pyGKbU.png" alt="Untitled"></p><p>进入cmake-build-release目录，直接单独编译这个模块 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211O3gnpL.png" alt="Untitled"></p><p>找到pass路径</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HdJCgu.png" alt="Untitled"></p><p>通过pass对ll文件进行处理生成bc文件，可以看到pass文件里面的语句被执行了，pass成功编译进去了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zyNbSL.png" alt="Untitled"></p><p>对函数名进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211i027Xc.png" alt="Untitled"></p><p>运行时函数名还是原来的，只是静态反编译的情况下会被混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fHCuPS.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数名加密pass&quot;&gt;&lt;a href=&quot;#函数名加密pass&quot; class=&quot;headerlink&quot; title=&quot;函数名加密pass&quot;&gt;&lt;/a&gt;函数名加密pass&lt;/h1&gt;&lt;p&gt;在Transforms下面创建EncodeFunctionName目录，创建一个En</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@OLLVM的几种混淆方法</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-11T07:38:37.000Z</published>
    <updated>2022-02-11T07:38:53.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM的几种混淆方法"><a href="#OLLVM的几种混淆方法" class="headerlink" title="OLLVM的几种混淆方法"></a>OLLVM的几种混淆方法</h1><h2 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h2><p>写一个小程序进行测试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211kq8mx4.png" alt="Untitled"></p><p>导出环境变量，然后使用ollvm进行指令替换</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=<span class="regexp">/home/</span>ollvm/llvm-project-<span class="number">9.0</span><span class="number">.1</span>/llvm/cmake-build-release/bin:$PATH</span><br><span class="line">clang -mllvm -sub hello_ollvm.c -o hello_ollvm</span><br></pre></td></tr></table></figure><p>这是原版的 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117QDGLy.png" alt="Untitled"></p><p>这是经过ollvm指令替换的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211dDh3qJ.png" alt="Untitled"></p><h2 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h2><p>通过添加虚假的控制流程来实现混淆 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf hello_ollvm_bcf.c -o hello_ollvm_bcf</span><br></pre></td></tr></table></figure><p>其实它只会执行某一个地方，绝大多数的位置都不会执行</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116jg8yf.png" alt="Untitled"></p><h2 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h2><p>平坦化效果，通常有大量的while循环</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yOQoyR.png" alt="Untitled"></p><p>执行平坦化指令</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla hello_ollvm_fla.c -o hello_ollvm_fla</span><br></pre></td></tr></table></figure><p>平坦化效果</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211LSSV4t.png" alt="Untitled"></p><p>指定函数平坦化混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211ZfpTLA.png" alt="Untitled"></p><p>指定函数不混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211h0q4Nt.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM的几种混淆方法&quot;&gt;&lt;a href=&quot;#OLLVM的几种混淆方法&quot; class=&quot;headerlink&quot; title=&quot;OLLVM的几种混淆方法&quot;&gt;&lt;/a&gt;OLLVM的几种混淆方法&lt;/h1&gt;&lt;h2 id=&quot;指令替换&quot;&gt;&lt;a href=&quot;#指令替换&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@移植OLLVM到NDK中</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0NDK%E4%B8%AD/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0NDK%E4%B8%AD/</id>
    <published>2022-02-11T07:35:37.000Z</published>
    <updated>2022-02-11T07:37:18.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移植OLLVM到NDK中"><a href="#移植OLLVM到NDK中" class="headerlink" title="移植OLLVM到NDK中"></a>移植OLLVM到NDK中</h1><p>进入llvm目录，复制三个目录到NDK的linux-x86_64目录下，覆盖掉</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211YC0w65.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211y1T1CQ.png" alt="Untitled"></p><p>创建个c++项目</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116vpkRu.png" alt="Untitled"></p><p>默认的项目会使用自带的NDK，有的时候我们需要使用下载下来的ndk，只要在配置文件里指定一下ndk的目录就可以了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211591BRt.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NoXyzy.png" alt="Untitled"></p><p>添加ollvm声明，编译时会加入这些参数 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GQ2qqr.png" alt="image-20220211153712292"></p><p>写一个示例代码，太简单的话基本块很少，没法分割进行混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211xG3YYm.png" alt="Untitled"></p><p>编译成汇编</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211SJgBpL.png" alt="Untitled"></p><p>生成的在下面的目录里面</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116eynt1.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bKmHt0.png" alt="Untitled"></p><p>可以看到代码已经被混淆了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202118EP3h1.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移植OLLVM到NDK中&quot;&gt;&lt;a href=&quot;#移植OLLVM到NDK中&quot; class=&quot;headerlink&quot; title=&quot;移植OLLVM到NDK中&quot;&gt;&lt;/a&gt;移植OLLVM到NDK中&lt;/h1&gt;&lt;p&gt;进入llvm目录，复制三个目录到NDK的linux-x86_</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@移植OLLVM到单独的so</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0%E5%8D%95%E7%8B%AC%E7%9A%84so/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0%E5%8D%95%E7%8B%AC%E7%9A%84so/</id>
    <published>2022-02-11T07:30:37.000Z</published>
    <updated>2022-02-11T07:34:25.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移植OLLVM到单独的so"><a href="#移植OLLVM到单独的so" class="headerlink" title="移植OLLVM到单独的so"></a>移植OLLVM到单独的so</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>移植到单独的so，这样修改OLLVM就不用编译整个LLVM代码</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211YMpm31.png" alt="Untitled"></p><h2 id="ollvm目录"><a href="#ollvm目录" class="headerlink" title="ollvm目录"></a>ollvm目录</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NsUh5v.png" alt="Untitled"></p><p>include目录下的结构</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nvHsTY.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021172bFcm.png" alt="Untitled"></p><p>lib目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Gzru9L.png" alt="Untitled"></p><p>lib目录下的CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zMGlhd.png" alt="Untitled"></p><p>lib目录下的LLVMBuild.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211OL3X5P.png" alt="Untitled"></p><p>lib/Transforms目录下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ut70Tf.png" alt="Untitled"></p><p>lib/Transforms目录下的CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gT4jnD.png" alt="Untitled"></p><p>lib/Transforms目录下的LLVMBuild.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211vjmXnQ.png" alt="Untitled"></p><p>lib/Transforms目录下的Obfuscation目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211AXPl9G.png" alt="image-20220211153136224"></p><p>CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021197F1Ih.png" alt="image-20220211153148520"></p><h2 id="根目录下CMakeLists-txt"><a href="#根目录下CMakeLists-txt" class="headerlink" title="根目录下CMakeLists.txt"></a>根目录下CMakeLists.txt</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tuw8a4.png" alt="image-20220211153155749"></p><h2 id="用CLion进行编译"><a href="#用CLion进行编译" class="headerlink" title="用CLion进行编译"></a>用CLion进行编译</h2><p>只留下build版本，进行编译，生成了libLLVMObfuscation.a文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211jjWyAh.png" alt="image-20220211153209328"></p><p>给Obfuscation目录下的CMakeLists.txt文件添加一个MODULE标志 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211kwd393.png" alt="image-20220211153219001"></p><p>这时会生成一个LLVMObfuscation.so文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211a18OUC.png" alt="image-20220211153239858"></p><p>ollvm是通过在PassManagerBuilder.cpp中注册绑定参数</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211oga8TT.png" alt="image-20220211153247761"></p><p>在lib/Transforms/Obfuscation目录下创建Entry.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211dwTVBJ.png" alt="image-20220211153301860"></p><p>把Entry.cpp放到Obfuscation目录下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021136vHl8.png" alt="image-20220211153309077"></p><p>添加命名空间</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ivsfsp.png" alt="image-20220211153315511"></p><p>添加额外的头文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211UgxZBs.png" alt="image-20220211153322135"></p><p>最后进行注册</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HJ1dHE.png" alt="image-20220211153329285"></p><p>找到之前编译的clang的路径</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211lVE29w.png" alt="image-20220211153336825"></p><p>Program arguments填入下面的参数，编译生成ll文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xclang -load -Xclang /OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -fla /home/hello_ollvm_fla.c -emit-llvm -S -o /home/hello_ollvm_fla.ll</span><br></pre></td></tr></table></figure><h2 id="调试ollvm"><a href="#调试ollvm" class="headerlink" title="调试ollvm"></a>调试ollvm</h2><p>也可以下断点进行调试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211vxRnIZ.png" alt="image-20220211153344796"></p><p>断点没有断下来，执行一个异常看下代码有没有被执行</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VT7iPq.png" alt="image-20220211153352097"></p><p>程序崩溃，看到个clang-9，这条指令是真正的编译指令 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211K0Ftkp.png" alt="image-20220211153400066"></p><p>看下这个clang工具，发现它有个软链接指向了clang-9</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211amfy2Q.png" alt="image-20220211153407036"></p><p>把clang-9的参数拷贝过来，选择clang-9程序</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sTwiUV.png" alt="image-20220211153413647"></p><p>再重新下断点并调试，这时程序正常断下了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bl2joT.png" alt="image-20220211153420188"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移植OLLVM到单独的so&quot;&gt;&lt;a href=&quot;#移植OLLVM到单独的so&quot; class=&quot;headerlink&quot; title=&quot;移植OLLVM到单独的so&quot;&gt;&lt;/a&gt;移植OLLVM到单独的so&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@OLLVM移植到新版本LLVM</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%A7%BB%E6%A4%8D%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%ACLLVM/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%A7%BB%E6%A4%8D%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%ACLLVM/</id>
    <published>2022-02-11T07:25:37.000Z</published>
    <updated>2022-02-11T07:26:27.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM移植到新版本LLVM"><a href="#OLLVM移植到新版本LLVM" class="headerlink" title="OLLVM移植到新版本LLVM"></a>OLLVM移植到新版本LLVM</h1><p>由于OLLVM已经好几年没有更新了，最近的更新还是基于LLVM4.0的</p><p>进入ollvm github仓库查看文件可以看到修改的位置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211t33Jkn.png" alt="Untitled"></p><p>下载ollvm</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nxMT6F.png" alt="Untitled"></p><p>切换到llvm-4.0分支</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Kk1CrI.png" alt="Untitled"></p><p>把Obfuscation目录复制到llvm的Transforms目录下 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pVXCy6.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Hd5Qb8.png" alt="Untitled"></p><p>修改Transforms/CMakeLists.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211XKN0eh.png" alt="Untitled"></p><p>修改Transform/LLVMBuild.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mhJCkz.png" alt="Untitled"></p><p>进入IPO目录，找到PassManagerBuilder.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hZ8ijP.png" alt="Untitled"></p><p>如果路径下的文件不存在，把文件拷贝到路径下就可以了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Nvg1AQ.png" alt="Untitled"></p><p>可以通过查看github上面的文件修改历史知道做了哪些改动</p><p>PassManagerBuilder.cpp还添加了下面的代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211n3ZKG3.png" alt="Untitled"></p><p>初始化了AesSeed，这些代码都是LLVM没有的，在移植过去的时候需要添加，另外还有一些简单的改动文件，移植的时候注意下就可以了，这里就不一一截图了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wAGPfj.png" alt="Untitled"></p><p>修改好了以后就可以用ninja LLVMObfuscation编译OLLVM了 </p><p>OLLVM有些bug被修复了，根据这些修改对文件进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211PHJN23.png" alt="Untitled"></p><p>使用ninja clang指令进行编译，如果顺利就移植成功了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM移植到新版本LLVM&quot;&gt;&lt;a href=&quot;#OLLVM移植到新版本LLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM移植到新版本LLVM&quot;&gt;&lt;/a&gt;OLLVM移植到新版本LLVM&lt;/h1&gt;&lt;p&gt;由于OLLVM已经好几年没有更新了，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@pass基本使用</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-11T07:19:37.000Z</published>
    <updated>2022-02-11T07:21:50.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pass基本使用"><a href="#pass基本使用" class="headerlink" title="pass基本使用"></a>pass基本使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>pass是LLVM里面重要的框架，不同的pass用于源代码在编译之前进行优化，可以复杂化也可以简单化，ollvm就是pass的一种</p><p>下图对bc文件执行了pass，bc文件是机器语言，但是通过—print-bb这个pass，可以打印中间代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211u3Xq8m.png" alt="Untitled"></p><p>每个pass都会调用runOnFunction函数，可以对要处理的函数进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nsZXyP.png" alt="Untitled"></p><h2 id="pass使用方法"><a href="#pass使用方法" class="headerlink" title="pass使用方法"></a>pass使用方法</h2><p>pass在llvm根目录下lib文件夹的Transforms文件夹中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211j9yz7h.png" alt="Untitled"></p><p>在进行编译时,目标程序的函数都会传递给runOnFunction函数，这个pass只是打印了函数的名字</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ksp67O.png" alt="Untitled"></p><p>查看这个pass的CMakeLists.txt文件，添加opt，那么就会生成对应的so文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116LgN3m.png" alt="Untitled"></p><p>生成的pass名字是LLVMHello.so</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211xho6og.png" alt="Untitled"></p><p>下图是使用自定义pass的命令，-hello是自定义pass定义的参数，可以看到这个pass的功能是打印了一个函数名称main</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fPzoLR.png" alt="Untitled"></p><p>再给C文件添加个函数test_hello1</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Uupk4q.png" alt="Untitled"></p><p>hello.clang.ll还存在一些外部的函数，比如说printf，它不受pass影响，所以这个函数名没有打印出来，pass只能优化我们自己写的代码 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Wao4vg.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pass基本使用&quot;&gt;&lt;a href=&quot;#pass基本使用&quot; class=&quot;headerlink&quot; title=&quot;pass基本使用&quot;&gt;&lt;/a&gt;pass基本使用&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@LLVM基础：编译、调试、工具</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@LLVM%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E8%B0%83%E8%AF%95%E3%80%81%E5%B7%A5%E5%85%B7/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@LLVM%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E8%B0%83%E8%AF%95%E3%80%81%E5%B7%A5%E5%85%B7/</id>
    <published>2022-02-11T07:15:37.000Z</published>
    <updated>2022-02-11T07:21:40.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLVM基础：编译、调试、工具"><a href="#LLVM基础：编译、调试、工具" class="headerlink" title="LLVM基础：编译、调试、工具"></a>LLVM基础：编译、调试、工具</h1><h2 id="LLVM简介"><a href="#LLVM简介" class="headerlink" title="LLVM简介"></a>LLVM简介</h2><p>LLVM包含了很多项目 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211AkfVtX.png" alt="Untitled"></p><h2 id="llvm下载"><a href="#llvm下载" class="headerlink" title="llvm下载"></a>llvm下载</h2><p>ndk的llvm/bin目录下，有llvm套件，可以查看这些工具的版本，然后在llvm官网下载相近的版本就可以了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clang --version</span><br></pre></td></tr></table></figure><p>llvm源码目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117mMtGq.png" alt="Untitled"></p><h2 id="llvm编译"><a href="#llvm编译" class="headerlink" title="llvm编译"></a>llvm编译</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>进入llvm.org/docs找到llvm文档，按照文档中环境要求进行安装和配置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GIDrhI.png" alt="Untitled"></p><p>有个方便的做法是把安卓源码依赖的程序全部安装上，这样基本就满足了llvm编译的环境要求了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211M7Syja.png" alt="Untitled"></p><h3 id="编译debug版本"><a href="#编译debug版本" class="headerlink" title="编译debug版本"></a>编译debug版本</h3><p>进入llvm根目录创建build_debug目录并进入该目录，执行下面的命令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mgCSNc.png" alt="Untitled"></p><p>然后再执行ninja -j8命令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Q8e6Tn.png" alt="Untitled"></p><h3 id="编译release版本"><a href="#编译release版本" class="headerlink" title="编译release版本"></a>编译release版本</h3><p>在根目录下创建build_release目录并进入这个目录下，执行下面的命令</p><p>-DLLVM_ENABLE_PROJECTS=”clang”的意思添加编译clang程序，这样生成的bin目录下就有clang的可执行程序了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b015uU.png" alt="Untitled"></p><h3 id="使用CLion进行编译"><a href="#使用CLion进行编译" class="headerlink" title="使用CLion进行编译"></a>使用CLion进行编译</h3><p>打开项目，路径选择根目录llvm目录下的CMakeLists.txt文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yros28.png" alt="Untitled"></p><p>进入设置，指定编译选项</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211JMuA3C.png" alt="Untitled"></p><p>点击确定之后项目会自动进行build</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211uKw8bl.png" alt="Untitled"></p><p>关闭CLion，进入命令行执行ninja -j8进行编译 </p><p>可以给CLion增加内存</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211QlkRNp.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wC6Esy.png" alt="Untitled"></p><p>也可以进入cmake-build-debug目录单独编译某一个项目，比如说clang</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yHWUtS.png" alt="Untitled"></p><h2 id="测试编译的Clang程序"><a href="#测试编译的Clang程序" class="headerlink" title="测试编译的Clang程序"></a>测试编译的Clang程序</h2><p>写一个简单的C文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sBvRcw.png" alt="Untitled"></p><p>控制台添加刚编译的clang程序的环境变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=<span class="regexp">/home/</span>ollvm/llvm-project-<span class="number">9.0</span><span class="number">.1</span>/llvm/cmake-build-debug/bin:$PATH</span><br></pre></td></tr></table></figure><p>使用clang对C文件进行编译并运行 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang hello_clang.c -o hello_clang</span><br><span class="line">./hello_clang</span><br></pre></td></tr></table></figure><h2 id="调试编译的Clang程序"><a href="#调试编译的Clang程序" class="headerlink" title="调试编译的Clang程序"></a>调试编译的Clang程序</h2><p>找到clang程序  </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hD618k.png" alt="Untitled"></p><p>设置路径为刚才编辑的c文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b85gdL.png" alt="Untitled"></p><p>点击确定后，目录下生成了一个可执行文件hello_clang_clion</p><p>然后找到clang目录下的tools里面的driver.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211lWnJdN.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gEg0ov.png" alt="Untitled"></p><p>在main函数下断点就可以对clang进行调试了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202113lBfwn.png" alt="Untitled"></p><h2 id="调试opt程序"><a href="#调试opt程序" class="headerlink" title="调试opt程序"></a>调试opt程序</h2><p>找到opt，然后进入配置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sf5Tbi.png" alt="Untitled"></p><p>把下图的参数填入Program arguments中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Xvz3xM.png" alt="Untitled"></p><p>hello_clang.dll文件路径需要修改为绝对路径，如果程序无法运行，可以把so文件路径的单引号去掉试试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211ze7uCf.png" alt="Untitled"></p><p>opt工具在tools文件夹下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sD4R2X.png" alt="Untitled"></p><p>然后在main函数中下断，之后就可以进行调试了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211T9Af1l.png" alt="Untitled"></p><p>中间文件的源文件也可以下断点进行调试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211J7A1z7.png" alt="Untitled"></p><h2 id="llvm工具"><a href="#llvm工具" class="headerlink" title="llvm工具"></a>llvm工具</h2><h3 id="编译中间语言"><a href="#编译中间语言" class="headerlink" title="编译中间语言"></a>编译中间语言</h3><p>编译成中间语言，中间语言可以转为不同平台的汇编语言</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S hello_clang.c -o hello_clang.ll</span><br></pre></td></tr></table></figure><p>生成的ll文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Lri4fu.png" alt="Untitled"></p><p>中间语言文件一样可以被执行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lli hello_clang.ll</span><br></pre></td></tr></table></figure><h3 id="llvm-as工具"><a href="#llvm-as工具" class="headerlink" title="llvm-as工具"></a>llvm-as工具</h3><p>转为汇编之前要先转为bitcode文件，通过llvm-as工具完成</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-<span class="keyword">as</span> hello_clang.ll -o hello_clang.bc</span><br></pre></td></tr></table></figure><h3 id="llc工具"><a href="#llc工具" class="headerlink" title="llc工具"></a>llc工具</h3><p>通过llc工具把bitcode文件转为汇编文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello_clang.bc -o hello_clang.s</span><br></pre></td></tr></table></figure><h3 id="llvm-dis工具"><a href="#llvm-dis工具" class="headerlink" title="llvm-dis工具"></a>llvm-dis工具</h3><p>通过llvm-dis工具将bitcode文件转为中间文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis hello_clang.bc -o hello_clang_re.ll</span><br></pre></td></tr></table></figure><h3 id="opt工具"><a href="#opt工具" class="headerlink" title="opt工具"></a>opt工具</h3><p>opt工具主要的作用有两个：</p><ul><li>查看bitcode文件</li><li>对bc文件或ll文件执行pass</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLVM基础：编译、调试、工具&quot;&gt;&lt;a href=&quot;#LLVM基础：编译、调试、工具&quot; class=&quot;headerlink&quot; title=&quot;LLVM基础：编译、调试、工具&quot;&gt;&lt;/a&gt;LLVM基础：编译、调试、工具&lt;/h1&gt;&lt;h2 id=&quot;LLVM简介&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组加密算法的的填充模式和工作模式</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-11T07:12:37.000Z</published>
    <updated>2022-02-11T07:12:45.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组加密算法的的填充模式和工作模式"><a href="#分组加密算法的的填充模式和工作模式" class="headerlink" title="分组加密算法的的填充模式和工作模式"></a>分组加密算法的的填充模式和工作模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分组密码分别支持的工作模式和填充模式</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211iFK4Nh.png" alt="%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2078d599c8de674cdab241a48fbd86e55f/Untitled.png"></p><h2 id="分组密码的填充模式"><a href="#分组密码的填充模式" class="headerlink" title="分组密码的填充模式"></a>分组密码的填充模式</h2><p>明文长度不够一个分组时：对不够一个分组大小时，制定一定的标准进行填充，使加密内容的长度到达一个分组大小；在解密时按照相同的标准再将填充部分删掉即可。有时，对于恰好已经是一个明文长度的分组也会填充，这时就会填充一个新的分组。</p><h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>即对每一个明文分组加密的方式，主要有以下几种：</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211o9zTeF.png" alt="%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2078d599c8de674cdab241a48fbd86e55f/Untitled%201.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组加密算法的的填充模式和工作模式&quot;&gt;&lt;a href=&quot;#分组加密算法的的填充模式和工作模式&quot; class=&quot;headerlink&quot; title=&quot;分组加密算法的的填充模式和工作模式&quot;&gt;&lt;/a&gt;分组加密算法的的填充模式和工作模式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组密码之AES</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES/</id>
    <published>2022-02-11T07:10:37.000Z</published>
    <updated>2022-02-11T07:11:41.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组密码之AES"><a href="#分组密码之AES" class="headerlink" title="分组密码之AES"></a>分组密码之AES</h1><p>以AES-128为例，会对明文分组进行10轮迭代运算，加密的第1轮到第9轮的轮函数一样，包括4个操作：字节替换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111r6VS2.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES%208f5210e1a4174f6a8f8795491ae7e026/Untitled.png"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211woepIT.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES%208f5210e1a4174f6a8f8795491ae7e026/Untitled%201.png"></p><p>字节代替：字节代替的主要是通过s盒完成一个字节到另一个字节的映射</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Lldjvz.png" alt="Untitled"></p><p>行位移：第一行保持不变，第二行循环左移1个字节，第三行循环左移2个字节，第四行循环左移3个字节 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b5UQNG.png" alt="Untitled"></p><p>列混淆：主要用于提供AES算法的扩散性，对列混淆矩阵相乘得到结果</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211D1a67h.png" alt="Untitled"></p><p>轮密钥加：每轮的输入与轮密钥异或一次（当前分组和扩展密钥的一部分进行按位异或），因为二进制连续异或一个数结果是不变的，所以在解密时再异或该密钥就可恢复</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组密码之AES&quot;&gt;&lt;a href=&quot;#分组密码之AES&quot; class=&quot;headerlink&quot; title=&quot;分组密码之AES&quot;&gt;&lt;/a&gt;分组密码之AES&lt;/h1&gt;&lt;p&gt;以AES-128为例，会对明文分组进行10轮迭代运算，加密的第1轮到第9轮的轮函数一样，包括</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组密码之DES</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES/</id>
    <published>2022-02-11T07:09:37.000Z</published>
    <updated>2022-02-11T07:09:27.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组密码之DES"><a href="#分组密码之DES" class="headerlink" title="分组密码之DES"></a>分组密码之DES</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DES算法会将明文按64位进行分组，密钥长64位，其中有56位参与DES运算，其余的几位是检验位，分组后的明文会跟56位密钥进行按位替代或交换形成密文</p><p>每次加密会对64位明文进行16轮编码，每一轮都会用密钥生成的子密钥进行运算</p><p>DES主要的处理过程分为两部分，首先是密钥的生成，然后是明文的处理</p><p><img src="https://s2.loli.net/2022/02/11/mEyAYxR1QSb4Bhu.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled.png"></p><h2 id="DES算法中出现的常量表"><a href="#DES算法中出现的常量表" class="headerlink" title="DES算法中出现的常量表"></a>DES算法中出现的常量表</h2><p>在对每一个64位明文分组进行处理的过程中，有大量常量表参与，从而完成对明文的混淆、扩散等处理。主要常量表有：初始置换表、逆初始置换表、扩展置换E表、8个s-box，这些常量都是快速判断DES算法的标志</p><p><img src="https://s2.loli.net/2022/02/11/hSwx82KXNmYZLzo.png" alt="Untitled"></p><p>在针对明文分组16轮处理过程中，每一轮都需要一个由原始56位密钥经过编排生成的48位子密钥的参与，这个过程中也出现了一些常量表，主要有：初始置换PC-1表、PC-2表</p><p><img src="https://s2.loli.net/2022/02/11/EcxWTZ5LNCmt36J.png" alt="Untitled"></p><h2 id="双重DES和三重DES"><a href="#双重DES和三重DES" class="headerlink" title="双重DES和三重DES"></a>双重DES和三重DES</h2><p>双重DES就是首先用key1对明文进行加密得到加密字符串，再用key2对加密字符串再进行加密得到最终加密字符串</p><p>三重DES是类似的概念，只是加密多加了一轮</p><h2 id="Java中使用DES加密"><a href="#Java中使用DES加密" class="headerlink" title="Java中使用DES加密"></a>Java中使用DES加密</h2><p>Java中使用DES算法</p><p><img src="https://s2.loli.net/2022/02/11/lKZ1G2kadeSUWy9.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%203.png"></p><p>iv是初始化向量参数</p><p>PKCS5Padding表示分组的填充方式</p><p><img src="https://s2.loli.net/2022/02/11/1PwoyYEqrcHkQ4p.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%204.png"></p><h2 id="对DES加密进行hook"><a href="#对DES加密进行hook" class="headerlink" title="对DES加密进行hook"></a>对DES加密进行hook</h2><p>下面有些函数需要重载</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.use(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).getInstance.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.getInstance is called!&#x27;</span>,arg0);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">this</span>.getInstance(arg0);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        Java.use(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).init.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg0,arg1,arg2</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>,arg0,arg1,arg2);</span><br><span class="line">            <span class="keyword">var</span> mode = arg0;</span><br><span class="line">            <span class="keyword">var</span> key = arg1;</span><br><span class="line">            <span class="keyword">var</span> iv = arg2;</span><br><span class="line">            <span class="keyword">var</span> key_bytes = key.getEncoded();</span><br><span class="line">            <span class="keyword">var</span> iv_bytes = iv.getIV();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>,mode,key_bytes,iv_bytes);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">this</span>.init(arg0,arg1,arg2);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES的识别"><a href="#DES的识别" class="headerlink" title="DES的识别"></a>DES的识别</h2><p>可以使用findcrypt3进行识别 ，这个插件通过识别常量来判断有没有加密，是哪种加密</p><p><img src="https://s2.loli.net/2022/02/11/NUj3snxCvqMDBip.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%205.png"></p><p>所以我们也可以自己写规则，用来识别加密算法，现在很多用的都不是标准DES的S盒，因此标准DES反而识别不出来，需要自己写规则识别</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211MIt04G.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%206.png"></p><p>另外，可以在IDA中搜E_table这样的字符串，然后把字符串的值填到规则里面</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fEFP48.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%207.png"></p><p>当然也可以通过hook api查看DES加密函数有没有被调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组密码之DES&quot;&gt;&lt;a href=&quot;#分组密码之DES&quot; class=&quot;headerlink&quot; title=&quot;分组密码之DES&quot;&gt;&lt;/a&gt;分组密码之DES&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@RC4算法</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@RC4%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@RC4%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-11T07:00:37.000Z</published>
    <updated>2022-02-11T07:00:52.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RC4算法主要有两个算法构成，一个是初始化算法（KSA），还有一个是伪随机子密码生成算法（PRGA）</p><p><img src="https://s2.loli.net/2022/02/11/sg2PYmUJLtMQfkA.png" alt="Untitled"></p><p>KSA算法部分，参数1是一个长度为256的char数组，参数2是密钥，可以任意定义，参数3是密钥的长度，密钥的主要功能是将s-box打乱</p><p><img src="https://s2.loli.net/2022/02/11/hYlXEuRKs2q8cez.png" alt="Untitled"></p><p>PRGA算法，参数1是被打乱的s-box，参数2是需要加密的数据</p><p><img src="https://s2.loli.net/2022/02/11/Z1xzkGXUrbIfYn5.png" alt="Untitled"></p><h2 id="RC4加密算法的识别"><a href="#RC4加密算法的识别" class="headerlink" title="RC4加密算法的识别"></a>RC4加密算法的识别</h2><p>1、RC4算法加密的字符串有一个特点，明文和密文长度相等</p><p>2、逆向算法，找到KSA算法，有两轮非常明显的长度为256的循环体</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RC4算法&quot;&gt;&lt;a href=&quot;#RC4算法&quot; class=&quot;headerlink&quot; title=&quot;RC4算法&quot;&gt;&lt;/a&gt;RC4算法&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@HMAC算法逆向与还原</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@HMAC%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@HMAC%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/</id>
    <published>2022-02-11T06:57:37.000Z</published>
    <updated>2022-02-11T06:58:04.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HMAC算法逆向与还原"><a href="#HMAC算法逆向与还原" class="headerlink" title="HMAC算法逆向与还原"></a>HMAC算法逆向与还原</h1><h2 id="HMAC算法还原"><a href="#HMAC算法还原" class="headerlink" title="HMAC算法还原"></a>HMAC算法还原</h2><p>HMAC有一个key，并且可以选择多种不同的哈希算法</p><p>目标程序对字符串进行加密，算法是HMAC</p><p><img src="https://s2.loli.net/2022/02/11/dwgu7GhSn4RkxEV.png" alt="Untitled"></p><p>核心加密函数，传递了一个字符串kanxue_imyang</p><p><img src="https://s2.loli.net/2022/02/11/Z728GloLjqYsNn4.png" alt="Untitled"></p><p>翻算法找到常量</p><p><img src="https://s2.loli.net/2022/02/11/vpjFLcUTuQ4Y6rC.png" alt="Untitled"></p><p>然后google搜到算法源码，根据源码可以知道这个函数是md5_transform</p><p><img src="https://s2.loli.net/2022/02/11/tA7gdIKsjTu864M.png" alt="Untitled"></p><p>它的上级函数是md5_update</p><p><img src="https://s2.loli.net/2022/02/11/MJke5gPATpEUcKu.png" alt="Untitled"></p><p>地址是0xaf84</p><p><img src="https://s2.loli.net/2022/02/11/CURcih9sAHrJV6y.png" alt="Untitled"></p><p>对md5_update函数进行hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    var base_native_lib = Module.findBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;base_native_lib address:&quot;</span>,base_native_lib);</span><br><span class="line">    var md5_update = base_native_lib.add(<span class="number">0xAF84</span> + <span class="number">1</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;md5_update address:&quot;</span>,md5_update);</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(md5_update,&#123;</span><br><span class="line">        onEnter : function(args)&#123;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;md5_update:&quot;</span>,hexdump(args[<span class="number">1</span>],&#123;length : parseInt(args[<span class="number">2</span>])&#125;),args[<span class="number">0</span>]);</span><br><span class="line">        &#125;,onLeave : function(retval)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(test,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>每次加密都会调用8次md5_update函数 </p><p><img src="https://s2.loli.net/2022/02/11/YQLyX6a9t3RF45H.png" alt="Untitled"></p><p>打印一下md5_update调用堆栈，大部分上层函数都指向了0xb738</p><p>接着hook sub_b738</p><p><img src="https://s2.loli.net/2022/02/11/j8BO6CbxMVthdSy.png" alt="Untitled"></p><p>hexdump打印一下sub_b738的内存，可以看到sub_b738的参数的值，每次执行算法时都会调用两次sub_b738函数 </p><p><img src="https://s2.loli.net/2022/02/11/dDt1RmsvX2nFQT7.png" alt="Untitled"></p><p>第二次</p><p><img src="https://s2.loli.net/2022/02/11/5VeKRdbH2oUh3XD.png" alt="Untitled"></p><p>把上面两次md5_update传递的字符串进行拼接再进行md5运算，结果跟第二次调用sub_b738时的第一个参数是一致的</p><p><img src="https://s2.loli.net/2022/02/11/IRm2HQk93UxGq6E.png" alt="Untitled"></p><p>hook最上级函数sub_b9f4，在OnLeave的时候看下传出来的值</p><p><img src="https://s2.loli.net/2022/02/11/1Tce3rpG9luvRE7.png" alt="Untitled"></p><p>hook这几个参数发现跟ida的反编译结果不太一样，根据打印的值猜测前面是字符串，后面是长度</p><p><img src="https://s2.loli.net/2022/02/11/hNYUayKuIRsAEzD.png" alt="Untitled"></p><p>所以可以打印3组数据 </p><p><img src="https://s2.loli.net/2022/02/11/VQLJuh1ti7w4Co2.png" alt="Untitled"></p><p>第一组数据是4e704c….</p><p>第二组数据是kanxue_imyang</p><p>第三组数据是4498220e，这个字符串跟加密的字符串是一致的</p><p><img src="https://s2.loli.net/2022/02/11/XmuliQHvAbhItFR.png" alt="Untitled"></p><p>所以最后一个参数应该就是加密的字符串了</p><p><img src="https://s2.loli.net/2022/02/11/kFKogC7WayQZrOR.png" alt="Untitled"></p><p>进入sub_b9f4函数可以看到result_buffer调用的地方</p><p><img src="https://s2.loli.net/2022/02/11/y9vEBGsSfHdVihu.png" alt="Untitled"></p><p>接着hook sub_b738，此时对应的加密字符串是82900068….</p><p>进入sub_b738时</p><p><img src="https://s2.loli.net/2022/02/11/fPXLdhk2BzH6ulA.png" alt="Untitled"></p><p>可以看到进入sub_b738函数前，有两次md5_update，第二次md5_update的值跟sub_b738第一个参数是一样的</p><p><img src="https://s2.loli.net/2022/02/11/MTR7XH3SApqt2fK.png" alt="Untitled"></p><p>把这两次md5_update传递的字符串拼接到一起然后进入md5运算，得到的值就是最终的加密字符串了</p><p><img src="https://s2.loli.net/2022/02/11/y8AHCUlsf6zeQL2.png" alt="Untitled"></p><p>在sub_b738函数内部又执行了两次md5_update</p><p><img src="https://s2.loli.net/2022/02/11/8twiFBpXHQ5jOKA.png" alt="Untitled"></p><p>执行完sub_b738时，可以看到执行完时就已经是加密后的字符串了</p><p><img src="https://s2.loli.net/2022/02/11/9Z7Ngn3wtxuFzyi.png" alt="Untitled"></p><p>两次md5_update然后执行sub_b738，这两次md5_update拼接的值是最终加密的字符串，在sub_b738内部又调用了两次md5_update，然后执行完毕，加密完成</p><p>其实源字符串通过hmac加密,key设置为kanxue_imyang结果跟上面是一样的，所以对于hmac加密只要找到key就可以了</p><p><img src="https://s2.loli.net/2022/02/11/b7fc89HmtqTveKh.png" alt="Untitled"></p><p>HMAC算法内部对key进行了异或之类的处理，处理之后的值再进行md5_update，也就是说HMAC算法不是仅仅进行了md5_update盐字符串拼接源字符串再进行哈希，还会对md5_update盐字符串进行处理，然后再拼接源字符串，最后进行哈希</p><h2 id="魔改异或值HMAC算法还原"><a href="#魔改异或值HMAC算法还原" class="headerlink" title="魔改异或值HMAC算法还原"></a>魔改异或值HMAC算法还原</h2><p>hook sub_1470c，可以看到key，不过通过HMAC算法对源字符串进行加密得出的结果跟最终加密的结果不一致，说明算法进行了魔改，最终的加密结果放在最后一个参数中了</p><p><img src="https://s2.loli.net/2022/02/11/Sw2gHYCRkz6AyF8.png" alt="Untitled"></p><p>对着参数按x，找到所有引用</p><p><img src="https://s2.loli.net/2022/02/11/Xa5CxySQc1O7NFu.png" alt="Untitled"></p><p>先进入sub_11DF0查看，根据内部的特征很有可能就是md5_transform</p><p><img src="https://s2.loli.net/2022/02/11/k3uYtUeOKPZpQDl.png" alt="Untitled"></p><p>它的上层函数就是md5_update</p><p><img src="https://s2.loli.net/2022/02/11/hjdm2PACRZgXws7.png" alt="Untitled"></p><p>hook md5_update</p><p><img src="https://s2.loli.net/2022/02/11/qRZMGh8F3u4UYkP.png" alt="Untitled"></p><p>可以看到md5_update的参数如下</p><p><img src="https://s2.loli.net/2022/02/11/xeodSYA7OwpL4Ur.png" alt="Untitled"></p><p>没有进行魔改的HMAC算法md5_udpate的参数是这样的，有大量的0x36</p><p><img src="https://s2.loli.net/2022/02/11/jtWeMVHB87pnfSq.png" alt="Untitled"></p><p>可以看到算法内部跟0x36异或的操作</p><p><img src="https://s2.loli.net/2022/02/11/ey4TJPqNOKBGh3X.png" alt="Untitled"></p><p>跟0x36异或算出来的结果就是Key</p><p><img src="https://s2.loli.net/2022/02/11/xIGlQucy3fOwKg4.png" alt="Untitled"></p><p>所以这个魔改的算法，修改了异或的值，把它跟0x88进行异或可以还原key</p><p><img src="https://s2.loli.net/2022/02/11/hUINW4fcgqteES3.png" alt="Untitled"></p><p>进行算法还原也很容易，找到HMAC的实现代码，把异或的值修改一下就可以了 </p><h2 id="HMAC-SHA256算法还原"><a href="#HMAC-SHA256算法还原" class="headerlink" title="HMAC-SHA256算法还原"></a>HMAC-SHA256算法还原</h2><p>sub_14D68函数的参数传递了一个缓冲区</p><p><img src="https://s2.loli.net/2022/02/11/rBd2RSuxLQ6kbz7.png" alt="Untitled"></p><p>打印看一下发现是kanxue_imgyang_52，因此这个函数应该就是核心算法函数 </p><p><img src="https://s2.loli.net/2022/02/11/HQufiqovYgS1ZJF.png" alt="Untitled"></p><p>进入函数因为有混淆，所以跟踪第一个参数的调用情况，然后找到了一些常量，google后确认是sha256</p><p><img src="https://s2.loli.net/2022/02/11/RdUceilgrypYk24.png" alt="Untitled"></p><p>根据源码可以确认sub_15194就是sha256_init函数</p><p><img src="https://s2.loli.net/2022/02/11/VHYv5wQW6muOlLB.png" alt="Untitled"></p><p>回到上一层，可以确认sha256_init的参数来自于sub_15148的参数 </p><p><img src="https://s2.loli.net/2022/02/11/hWMcSfZFIGdK7Dq.png" alt="Untitled"></p><p>最终可以确认sub_14d68的第一个参数是sha256_ctx</p><p><img src="https://s2.loli.net/2022/02/11/NTFQOXquaADWhKl.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/cw6SloTr4KIG7py.png" alt="Untitled"></p><p>接着分析sub_9598，在里面找到常量，google一番找到标准算法搜索后看到是数组k里面的元素</p><p><img src="https://s2.loli.net/2022/02/11/3Lv6H5VowycksKx.png" alt="Untitled"></p><p>看到k在sha256_transform内部进行了引用 </p><p><img src="https://s2.loli.net/2022/02/11/1raQMfqB5d7pAEk.png" alt="Untitled"></p><p>因此这个函数就是sha256_transform</p><p><img src="https://s2.loli.net/2022/02/11/mpORoeUc4dy7l3X.png" alt="Untitled"></p><p>查源码sha256_transform的上一层是sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/5yIsP34EvOeNJxH.png" alt="Untitled"></p><p>因此sub_9598的内部调用的是sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/uSXTOJ1kLChsxQV.png" alt="Untitled"></p><p>对sha256_update进行hook</p><p><img src="https://s2.loli.net/2022/02/11/NQPO5ozZBLxgfeu.png" alt="Untitled"></p><p>对sub_15030进行hook</p><p><img src="https://s2.loli.net/2022/02/11/tBclgqS3WjZI58M.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/6Hex9YQtTS3UuFa.png" alt="Untitled"></p><p>可以通过打印参数获取地址，可以分辨是不是同一个sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/XM1zP85dsq9KCGp.png" alt="Untitled"></p><p>两个md5_update拼接生成3b999….</p><p><img src="https://s2.loli.net/2022/02/11/seSVZGIfkvmhObn.png" alt="Untitled"></p><p>再两次md5_update拼接生成最终加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/clpKr4tzX8Af2WZ.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/yPV9zpWo54CvwDF.png" alt="Untitled"></p><p>7=2$…字符串是key跟0x5c异或的结果，通过跟0x5c异或可以还原key</p><p><img src="https://s2.loli.net/2022/02/11/ydLZEYqSHkrw79t.png" alt="Untitled"></p><p>通过key生成加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/1o9CqjtmZRIOYEH.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HMAC算法逆向与还原&quot;&gt;&lt;a href=&quot;#HMAC算法逆向与还原&quot; class=&quot;headerlink&quot; title=&quot;HMAC算法逆向与还原&quot;&gt;&lt;/a&gt;HMAC算法逆向与还原&lt;/h1&gt;&lt;h2 id=&quot;HMAC算法还原&quot;&gt;&lt;a href=&quot;#HMAC算法还原&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
