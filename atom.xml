<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打渔为生</title>
  
  <subtitle>tutucoo的技术笔记</subtitle>
  <link href="https://tutucoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://tutucoo.github.io/"/>
  <updated>2022-02-11T08:27:21.150Z</updated>
  <id>https://tutucoo.github.io/</id>
  
  <author>
    <name>tutucoo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ollvm@frida辅助分析ollvm指令替换</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2/</id>
    <published>2022-02-11T08:20:37.000Z</published>
    <updated>2022-02-11T08:27:21.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="frida辅助分析ollvm指令替换"><a href="#frida辅助分析ollvm指令替换" class="headerlink" title="frida辅助分析ollvm指令替换"></a>frida辅助分析ollvm指令替换</h1><p>jni加密算法sign2</p><p><img src="https://s2.loli.net/2022/02/11/K5Cus7PxkzdYXpm.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled.png"></p><p>主动调用sign2</p><p><img src="https://s2.loli.net/2022/02/11/UKeEO2unG1h9APZ.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%201.png"></p><p>返回的sign有时候一样，有时候不一样</p><p><img src="https://s2.loli.net/2022/02/11/WI1N3XhPkjO9iTx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%202.png"></p><p>f5失败，可以加载jni.h文件，也可以通过加载类型库的方式解决</p><p><img src="https://s2.loli.net/2022/02/11/E9GrhMvBXCJ8iyj.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%203.png"></p><p><img src="https://s2.loli.net/2022/02/11/cUnvW25NksMAF8y.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%204.png"></p><p>看下JNIEnv的引用，v7改为_env</p><p><img src="https://s2.loli.net/2022/02/11/21drWsl6wkOSeZV.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%205.png"></p><p>接着hook sign2函数，看下GetStringUTFChars的参数</p><p><img src="https://s2.loli.net/2022/02/11/1UWB5nFedkamghG.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%206.png"></p><p>sign2的参数和返回值都打印出来了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sign2 str1: <span class="number">0123456789</span></span><br><span class="line">sign2 str2: abcdefg</span><br><span class="line">sign2 retval: a2c78374514d7934432cbc66cd1e293b</span><br></pre></td></tr></table></figure><p>先从sign2函数的str1参数开始分析，看到两处引用，赋值给了v5</p><p><img src="https://s2.loli.net/2022/02/11/5QNzY7VDJ6naWrl.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%207.png"></p><p>将v5改名为str_1_1，v8改为c_str_1</p><p>看下str_1_1的引用，发现是调用ReleaseStringUTFChars函数时使用的，所以接着看c_str_1</p><p><img src="https://s2.loli.net/2022/02/11/RicCdrHoIyUeJ2z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%208.png"></p><p>看下c_str_1的引用，调用了memcpy，赋值给了v11</p><p><img src="https://s2.loli.net/2022/02/11/U2vNXmsfREOeYMu.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%209.png"></p><p>v11引用，v11在c_str_1赋值后，后续没有再使用，所以分析v161</p><p><img src="https://s2.loli.net/2022/02/11/4sFvcwoZ7CK6L8H.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2010.png"></p><p>v161引用，203行之前的先不看，先看后面的</p><p>v161赋值给了v75，v75不是一个指针，先不看</p><p><img src="https://s2.loli.net/2022/02/11/H6iNjOlMJgcsYq3.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2011.png"></p><p>v161赋值给了v154，然后跳转到了LABEL_22</p><p><img src="https://s2.loli.net/2022/02/11/uA5etRabYTDKj6w.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2012.png"></p><p>看下v154的引用，看下sub_1DFB4</p><p><img src="https://s2.loli.net/2022/02/11/d8WbRYEt2qDulBN.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2013.png"></p><p>hook sub_1dfb4</p><p><img src="https://s2.loli.net/2022/02/11/AwVSPUHagrMEvq5.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2014.png"></p><p>sub_1dfb4的两个参数和返回值，看起来像个地址</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_1DFB4 <span class="number">0x74b5cc6b90</span> <span class="number">0x74b5cc6b70</span></span><br><span class="line">sub_1DFB4 onLeave <span class="number">0x74ce6855d0</span></span><br></pre></td></tr></table></figure><p>dump这些地址的内容</p><p><img src="https://s2.loli.net/2022/02/11/ZqhBs7lVrexo25P.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2015.png"></p><p>sub_1dfb4的第一个参数和第二个参数是传递进来的str1和str2</p><p><img src="https://s2.loli.net/2022/02/11/Tq23yM1pLzJsjow.png" alt="Untitled"></p><p>函数执行完返回的值是加密的，可以看出虽然sub_1dfb4反编译的时候没有返回值，但其实有返回值的 </p><p>可以看到sub_1dfb4的返回值跟最终的加密sign是一致的</p><p><img src="https://s2.loli.net/2022/02/11/MtIaiN7rZXojcBG.png" alt="Untitled"></p><p>在sub_1dfb4上面，有一堆指令替换的操作，本来很简单的指令弄的很复杂，这些都不用看，直接进入sub_1dfb4进行分析</p><p><img src="https://s2.loli.net/2022/02/11/H9ljMOKx5Z7BN1E.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2018.png"></p><p>进入sub_1dfb4，参数又变成了一个，这个不用管，在函数名上面右键Set item type，可以设置多个参数以及类型</p><p><img src="https://s2.loli.net/2022/02/11/ZutN4j13favW27H.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2019.png"></p><p><img src="https://s2.loli.net/2022/02/11/NwCoJOb6ETB9vFI.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2020.png"></p><p>查找两个参数的引用，发现是空</p><p>查看反汇编，并没有看到参数的痕迹，x0和x1并没有被使用，但是调用了sub_1e298，可能参数会直接传递到这个函数里面</p><p><img src="https://s2.loli.net/2022/02/11/DfRI9dp6mx5ao4b.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2021.png"></p><p>hook sub_1e298</p><p><img src="https://s2.loli.net/2022/02/11/Tbz8lNcCBxRSq4D.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2022.png"></p><p>可以看到sub_1e298的参数就是str1和str2</p><p><img src="https://s2.loli.net/2022/02/11/AhwTKHvEGo4JlaO.png" alt="Untitled"></p><p>先看一下参数1的引用，它的值给了v16和v17</p><p><img src="https://s2.loli.net/2022/02/11/ZD5tJH4u7oeEbSn.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2024.png"></p><p>然后看v16的引用，没有什么有价值的</p><p><img src="https://s2.loli.net/2022/02/11/dTwn7iFW8DY6lUG.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2025.png"></p><p>再看v17的引用，可以看到v17赋值给了v20</p><p><img src="https://s2.loli.net/2022/02/11/mjJLDFRNlokCzBi.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2026.png"></p><p>v20之前的值来自v28或者v5</p><p><img src="https://s2.loli.net/2022/02/11/dUghjsp4R8xGq6z.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2027.png"></p><p>先看下v28，v28没有什么东西，看下v5</p><p><img src="https://s2.loli.net/2022/02/11/ApdaMqnIEsbiwHt.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2028.png"></p><p>v5里面调用了一个函数</p><p><img src="https://s2.loli.net/2022/02/11/hmFaoCpOwlMnJVU.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2029.png"></p><p>可以看到v5两处调用，因为sub_1ab0上面调用了memcpy，把str1赋值给了v20，所以下面要对sub_1ab50进行hook，看str1有没有传递</p><p><img src="https://s2.loli.net/2022/02/11/JW63tRalKoe8bQx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2030.png"></p><p>hook它的三个参数和返回值 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_1AB50 = base_hello_jni.add(<span class="number">0x1AB50</span>);</span><br><span class="line">Interceptor.attach(sub_1AB50, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB50 onEnter:&quot;</span>,(args[<span class="number">0</span>]),<span class="string">&quot;\r\n&quot;</span>,(args[<span class="number">1</span>]),args[<span class="number">2</span>]);</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB50 onLeave:&quot;</span>,retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两次调用了sub_1ab50，参数1和参数2是个指针，参数3应该是个长度</p><p><img src="https://s2.loli.net/2022/02/11/j6OxaL3FZy8cGYW.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2031.png"></p><p>dump一下地址，可以看到这个函数返回的内容</p><p><img src="https://s2.loli.net/2022/02/11/qoyu3d6Qc7pfHSA.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2032.png"></p><p>第二次调用是传递的加盐字符串</p><p><img src="https://s2.loli.net/2022/02/11/vwJWDUOt6rAeFZq.png" alt="Untitled"></p><p>返回了加盐拼接字符串</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++++++salt2+</span><br></pre></td></tr></table></figure><p>所以可以认为sub_1ab50函数的功能主要是拼接字符串的</p><p>hook sub_1e298的返回值</p><p><img src="https://s2.loli.net/2022/02/11/k3SlnwJTLrOjhER.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2034.png"></p><p>可以看到也是返回的拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/rUYjIcRuTX5hHEl.png" alt="Untitled"></p><p>看下sub_1e298的返回值X0，虽然X0没有被使用，不过下面调用了sub_1ab4c</p><p><img src="https://s2.loli.net/2022/02/11/oynZ59Ae8vO6rUx.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2036.png"></p><p>反编译没有返回值，但是有三个参数，其中最后一个是返回值 </p><p><img src="https://s2.loli.net/2022/02/11/OURi9KlhWwLkIYm.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2037.png"></p><p>hook sub_1ab4c</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sub_1AB4C = base_hello_jni.add(<span class="number">0x1AB4C</span>);</span><br><span class="line">Interceptor.attach(sub_1AB4C, &#123;</span><br><span class="line">    onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB4C onEnter:&quot;</span>,args[<span class="number">0</span>],(args[<span class="number">1</span>]),args[<span class="number">2</span>]);</span><br><span class="line">    &#125;,<span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sub_1AB4C onLeave:&quot;</span>,retval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>hook结果 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub_1AB4C onEnter: <span class="number">0x74b5cc6ad9</span> <span class="number">0x11</span> <span class="number">0x74b5cc6b18</span></span><br><span class="line">sub_1AB4C onLeave: <span class="number">0x74b5cc6960</span></span><br><span class="line">sign2 retval: 43898b3fe54cfe43af19206c592acaf3</span><br></pre></td></tr></table></figure><p>sub_1ab4c第一个参数传递了拼接字符串，其他的参数和返回值没有有用的 </p><p><img src="https://s2.loli.net/2022/02/11/DRAHzrTn8ONkKLV.png" alt="Untitled"></p><p>因为它第三个参数可能是个返回值，所以函数执行完以后打印这个参数看下，可以看到这第三个参数确实就是最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/yckudsmgqaCvhVG.png" alt="Untitled"></p><p>sub_1ab4c就是核心的加密函数</p><p><img src="https://s2.loli.net/2022/02/11/SgvmrezJUEP2slM.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2040.png"></p><p>它的内部调用了sub_195bc</p><p><img src="https://s2.loli.net/2022/02/11/PzlEVZkbWm2d9OK.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2041.png"></p><p>首先看下input_buffer的引用</p><p><img src="https://s2.loli.net/2022/02/11/7YbPZSlhHdVxgnW.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2042.png"></p><p>v3改名为_input_buffer，再看_input_buffer的引用</p><p><img src="https://s2.loli.net/2022/02/11/Rmy56Pp7YbtIUcf.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2043.png"></p><p>hook sub_171c4函数，第1个参数有返回值 ，第2个参数是拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/EnyiVkFALfU7wI2.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2044.png"></p><p>看到都是指针，第一个参数跟返回值都是一样的地址</p><p><img src="https://s2.loli.net/2022/02/11/DGhjzkbv9l84Fm5.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2045.png"></p><p>hexdump看一下，第1个参数和返回值都是40，第2个参数是拼接字符串</p><p><img src="https://s2.loli.net/2022/02/11/RlkuUFdwyNVYc4p.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/wV6XWzrs3bnDB9M.png" alt="Untitled"></p><p>因为没有看到最终的加密字符串，进入sub_171c4函数看下</p><p>看到常量，搜索一下，搜索出来的结果显示这里是md5编码</p><p><img src="https://s2.loli.net/2022/02/11/VeCiOxslh6U5QPD.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2048.png"></p><p>可以看到对sub_171c4的第二个参数进行md5编码可以得到最终的加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/tl1NOwTGkKH8BpL.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2049.png"></p><p>算法总结：</p><p>1、0123456789拼接abcdefg</p><p>2、添加盐</p><p>3、md5运算</p><p>之所以每次加密的字符串都不一样是因为盐字符串每次都会变化</p><p><img src="https://s2.loli.net/2022/02/11/fxDFlqsYpOjegrZ.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2050.png"></p><p>查找盐字符串生成的函数</p><p><img src="https://s2.loli.net/2022/02/11/aKIEpNzMdRvkbnV.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2051.png"></p><p>可以看到是sub_1ab50返回的 </p><p><img src="https://s2.loli.net/2022/02/11/s4FYB5foe1UOQJn.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2052.png"></p><p>sub_1ab50内部调用了随机函数生成随机的盐字符串</p><p><img src="https://s2.loli.net/2022/02/11/Z1DTWUwVEG6KceX.png" alt="frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90ollvm%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%2013ef8eb0f39a411fb74779cf8a6a7e2d/Untitled%2053.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;frida辅助分析ollvm指令替换&quot;&gt;&lt;a href=&quot;#frida辅助分析ollvm指令替换&quot; class=&quot;headerlink&quot; title=&quot;frida辅助分析ollvm指令替换&quot;&gt;&lt;/a&gt;frida辅助分析ollvm指令替换&lt;/h1&gt;&lt;p&gt;jni加密算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@分析ollvm混淆的iqiyi sign算法</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-11T08:04:37.000Z</published>
    <updated>2022-02-11T08:08:57.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析ollvm混淆的iqiyi-sign算法"><a href="#分析ollvm混淆的iqiyi-sign算法" class="headerlink" title="分析ollvm混淆的iqiyi sign算法"></a>分析ollvm混淆的iqiyi sign算法</h1><p>sign算法是getQdscJNI函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.qiyi;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Protect</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getQdsc</span><span class="params">(Object obj, String str)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">return</span> getQdscJNI(obj, str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"> </span><br><span class="line">         &#125; <span class="keyword">catch</span> (UnsupportedEncodingException unused) &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// getQdsc内部调用的是native函数</span></span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getQdscJNI</span><span class="params">(Object obj, <span class="keyword">byte</span>[] bArr)</span></span>;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过 frida直接调用getQdsc函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">function <span class="title">call_getQdsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Java.perform(function () &#123;</span><br><span class="line">         <span class="keyword">var</span> currentApplication = Java.use(<span class="string">&quot;android.app.ActivityThread&quot;</span>).currentApplication();</span><br><span class="line">         <span class="keyword">var</span> context = currentApplication.getApplicationContext();</span><br><span class="line">         <span class="keyword">var</span> Protect = Java.use(<span class="string">&quot;com.qiyi.Protect&quot;</span>);</span><br><span class="line">         <span class="keyword">var</span> qdsc = Protect.getQdsc(context, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">         console.log(<span class="string">&quot;qdsc:&quot;</span>, qdsc);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> call_getQdsc()</span><br></pre></td></tr></table></figure><p>主动调用qdsc函数生成的字符串 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202118DpuVS.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled.png"></p><p>IDA加载<code>libprotect.so</code>，找到函数getQdscJNI</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111D0cUX.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%201.png"></p><p>先来看一个简单的ollvm 流程平坦化之后的流程图是怎么样的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bSPORR.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%202.png"></p><p>进入sub_126B4，看下整体流程图</p><p><img src="https://s2.loli.net/2022/02/11/GK3nHveY9Lq4w1o.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%203.png"></p><p>先来看看函数定义，由前面的调用参数可以知道a1是JNIEnv的指针，a3是一个char*的buffer，a4是buffer的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> unsigned int *__fastcall sub_126B4(JNIEnv *a1, int a2, char *buffer, int buffer_len)</span><br></pre></td></tr></table></figure><p>第一步找到buffer的交叉引用</p><p><img src="https://s2.loli.net/2022/02/11/wlBxLcZeGIdbkYf.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%204.png"></p><p>对v7 重命名为 buffer_1， 查看buffer_1的交叉引用，看到原始数据传入了sub_1189C</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cFW3Po.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%205.png"></p><p>查看sub_1189C</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> v70 &#x3D; (unsigned int *)sub_1189C(&amp;v103, buffer_1, v8);</span><br></pre></td></tr></table></figure><p>查看v8的引用,看到v8被参数buffLen赋值</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cnHYyc.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%206.png"></p><p>v8就是bufferLen， 对v8重命名为bufferLen_</p><p>sub_1189C 的后两个参数一个buffer, 一个是len, 因此先写一段frida脚本来hook sub_1189C函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> base_protect = Module.findBaseAddress(<span class="string">&quot;libprotect.so&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (base_protect) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;base_protect:&quot;</span>, base_protect);</span><br><span class="line">         <span class="keyword">var</span> sub_1189C = base_protect.add(<span class="number">0x1189C</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C:&quot;</span>, sub_1189C);</span><br><span class="line">         Interceptor.attach(sub_1189C, &#123;</span><br><span class="line">             onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">                 <span class="built_in">this</span>.buffer = args[<span class="number">1</span>];</span><br><span class="line">                 <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">2</span>]);</span><br><span class="line">                 <span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C onEnter:\n&quot;</span>, hexdump(<span class="built_in">this</span>.buffer, &#123; <span class="attr">length</span>: <span class="built_in">this</span>.len &#125;));</span><br><span class="line">             &#125;,</span><br><span class="line">             onLeave: <span class="function"><span class="keyword">function</span> (<span class="params">retval</span>) </span>&#123;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用call_getQdsc, 可以看到sub_1189C的参数buffer已经打印出来了，可以看到这时的buffer不再是123,而是aXFpqiyi.Protec=</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; hook_native()</span><br><span class="line"> </span><br><span class="line"> base_protect: 0xd0a64000</span><br><span class="line"> </span><br><span class="line"> sub_1189C: 0xd0a7589c</span><br><span class="line"> </span><br><span class="line"> undefined</span><br><span class="line"> </span><br><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; call_getQdsc()</span><br><span class="line"> </span><br><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c1505aa0 61 58 46 70 71 69 79 69 2e 50 72 6f 74 65 63 3d aXFpqiyi.Protec&#x3D;</span><br><span class="line"> </span><br><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> d160bd00 33 30 38 32 30 32 34 37 33 30 38 32 30 31 62 30 30820247308201b0</span><br><span class="line"> </span><br><span class="line"> d160bd10 61 30 30 33 30 32 30 31 30 32 30 32 30 34 34 63 a00302010202044c</span><br><span class="line"> </span><br><span class="line"> d160bd20 39 64 61 36 61 30 33 30 30 64 30 36 30 39 32 61 9da6a0300d06092a</span><br><span class="line"> </span><br><span class="line"> d160bd30 38 36 34 38 38 36 66 37 30 64 30 31 30 31 30 35 864886f70d010105</span><br><span class="line"> </span><br><span class="line"> d160bd40 30 35 30 30 33 30 36 37 33 31 30 62 33 30 30 39 05003067310b3009</span><br><span class="line"> </span><br><span class="line"> d160bd50 30 36 30 33 35 35 30 34 30 36 31 33 30 32 34 33 37af87</span><br><span class="line"> </span><br><span class="line"> qdsc: 616904a6660256fafef2db967eb82880</span><br></pre></td></tr></table></figure><p>补充一下，对sub_126b4进行hook，传进来123，123是怎么变成aXFpqiyi.Protec=的？</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yrQb2F.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%207.png"></p><p>暂时先不分析sub_1189C函数，先把sub_126B4的buffer参数引用分析完。</p><p>选择第三个引用</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pEvvbe.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%208.png"></p><p>再次查看ptr的交叉引用</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bN2xsK.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%209.png"></p><p>查看sub_11A68，两个参数一个buffer, 一个是len, 写一段frida脚本hook sub_11A68</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> sub_11A68 = base_protect.add(<span class="number">0x11A68</span>);</span><br><span class="line"> Interceptor.attach(sub_11A68, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.buffer = args[<span class="number">2</span>];</span><br><span class="line"> <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">3</span>]);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;sub_11A68 onEnter:\n&quot;</span>, ptr(<span class="built_in">this</span>.buffer).readCString(<span class="built_in">this</span>.len)); </span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>现在把引用buffer的几个函数都已经找到了，下面深入分析sub_1189C、sub_11A68这两个函数的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> </span><br><span class="line"> _BYTE *__fastcall sub_1189C(int a1, char *a2, int a3)</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;省略部分变量定义代码</span><br><span class="line"> </span><br><span class="line"> v3 &#x3D; a1;</span><br><span class="line"> </span><br><span class="line"> v4 &#x3D; a3;</span><br><span class="line"> </span><br><span class="line"> v5 &#x3D; a2;</span><br><span class="line"> </span><br><span class="line"> v6 &#x3D; malloc(0x21u);</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr(v6, 33);</span><br><span class="line"> </span><br><span class="line"> v21 &#x3D; 1732584193;</span><br><span class="line"> </span><br><span class="line"> v22 &#x3D; 4023233417;</span><br><span class="line"> </span><br><span class="line"> v23 &#x3D; 2562383102;</span><br><span class="line"> </span><br><span class="line"> v24 &#x3D; 271733878;</span><br><span class="line"> </span><br><span class="line"> v25 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> v26 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> sub_11A68(v3, (int)&amp;v21, (int)v5, v4);</span><br><span class="line"> </span><br><span class="line"> v7 &#x3D; v25;</span><br><span class="line"> </span><br><span class="line"> v8 &#x3D; (v25 &gt;&gt; 3) &amp; 0x3F;</span><br><span class="line"> </span><br><span class="line"> *((_BYTE *)&amp;v27 + v8) &#x3D; 0x80u;</span><br><span class="line"> </span><br><span class="line"> v9 &#x3D; v8 ^ 0x3F;</span><br><span class="line"> </span><br><span class="line"> v10 &#x3D; (char *)&amp;v27 + v8 + 1;</span><br><span class="line"> </span><br><span class="line"> if ( v9 &gt; 7 )</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr(v10, v9 - 8);</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> else</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> v11 &#x3D; _aeabi_memclr(v10, v9);</span><br><span class="line"> </span><br><span class="line"> sub_11CAC(v11, &amp;v21, &amp;v27);</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr4((int)&amp;v27, 56);</span><br><span class="line"> </span><br><span class="line"> v7 &#x3D; v25;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> v28 &#x3D; v7;</span><br><span class="line"> </span><br><span class="line"> v29 &#x3D; v26;</span><br><span class="line"> </span><br><span class="line"> sub_11CAC(v26, &amp;v21, &amp;v27);</span><br><span class="line"> </span><br><span class="line"> v17 &#x3D; v21;</span><br><span class="line"> </span><br><span class="line"> v18 &#x3D; v22;</span><br><span class="line"> </span><br><span class="line"> v19 &#x3D; v23;</span><br><span class="line"> </span><br><span class="line"> v20 &#x3D; v24;</span><br><span class="line"> </span><br><span class="line"> _aeabi_memclr4((int)&amp;v21, 88);</span><br><span class="line"> </span><br><span class="line"> v12 &#x3D; 0;</span><br><span class="line"> </span><br><span class="line"> do</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> v13 &#x3D; *((unsigned __int8 *)&amp;v17 + v12);</span><br><span class="line"> </span><br><span class="line"> v14 &#x3D; a0123456789abcd[v13 &gt;&gt; 4];</span><br><span class="line"> </span><br><span class="line"> LOBYTE(v13) &#x3D; a0123456789abcd[v13 &amp; 0xF];</span><br><span class="line"> </span><br><span class="line"> v6[2 * v12] &#x3D; v14;</span><br><span class="line"> </span><br><span class="line"> v15 &#x3D; (int)&amp;v6[2 * v12++];</span><br><span class="line"> </span><br><span class="line"> *(_BYTE *)(v15 + 1) &#x3D; v13;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> while ( v12 !&#x3D; 16 );</span><br><span class="line"> </span><br><span class="line"> result &#x3D; (_BYTE *)(_stack_chk_guard - v30);</span><br><span class="line"> </span><br><span class="line"> if ( _stack_chk_guard &#x3D;&#x3D; v30 )</span><br><span class="line"> </span><br><span class="line"> result &#x3D; v6;</span><br><span class="line"> </span><br><span class="line"> return result;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在算法分析过程中，首先看到类似第<code>37，38， 39，40行</code>这种的常量</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202112HYrSC.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2010.png"></p><p>如果你已经熟悉这个常量，就能猜到这个是什么算法，通过在算法文件中搜索67452301之后，发现md5, sha1都有<code>67452301, EFCDAB89, 98BADCFE, 10325476</code>这四个常量，而sha1多一个<code>C3D2E1F0</code></p><p>因此可以判断出<code>sub_1189C是一个与md5相关的函数</code></p><p>先对一些变量进行重命名</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hdK4LI.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2011.png"></p><p>进去 <code>sub_11A68</code> 看看</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mImKjZ.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2012.png"></p><p>sub_11A68函数里面对参数进行了一些计算，然后调用了sub_11CAC函数，在算法逆向过程中，遇到一些移位异或运算，先粗略看看，然后跳过，只有在算法还原的过程中才仔细分析这些运算</p><p>进去<code>sub_11CAC</code>看看</p><p><img src="https://s2.loli.net/2022/02/11/vakwigL45Z3uGzT.png" alt="image-20220211160742433"></p><p>把sub_11CAC函数中的用到常量与md5_process函数的常量比较发现，都是一样的。现在可以把sub_11CAC命名为md5_process了</p><p><img src="https://s2.loli.net/2022/02/11/dZwMuvA4RJHYtV8.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2014.png"></p><p>确定了md5_process函数之后，就可以确定它的上层函数sub_11A68为md5_update函数，</p><p>sub_11A68的上层函数sub_1189C这时候看起来就是一个md5函数的结构了</p><p><img src="https://s2.loli.net/2022/02/11/fW3Njx1TgYKbr6S.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2015.png"></p><p>frida打印出sub_1189C的返回值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> base_protect = Module.findBaseAddress(<span class="string">&quot;libprotect.so&quot;</span>);</span><br><span class="line"> <span class="keyword">var</span> sub_1189c = base_protect.add(<span class="number">0x1189c</span>); </span><br><span class="line"> Interceptor.attach(sub_1189c, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.buffer = args[<span class="number">1</span>];</span><br><span class="line"> <span class="built_in">this</span>.len = <span class="built_in">parseInt</span>(args[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sub_1189c onEnter:\n&quot;</span>, ptr(<span class="built_in">this</span>.buffer).readCString(<span class="built_in">this</span>.len));</span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sub_1189C onLeave retval:\n&quot;</span>, hexdump(retval, &#123; <span class="attr">length</span>: <span class="number">0x20</span> &#125;));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>aXFpqiyi.Protec=经过md5变成25c11bfb902a449f8d636900a3405419</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> sub_1189C onEnter:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c9463e48 61 58 46 70 71 69 79 69 2e 50 72 6f 74 65 63 3d aXFpqiyi.Protec&#x3D;</span><br><span class="line"> </span><br><span class="line"> sub_1189C onLeave retval:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> c62dd318 32 35 63 31 31 62 66 62 39 30 32 61 34 34 39 66 25c11bfb902a449f</span><br><span class="line"> </span><br><span class="line"> c62dd328 38 64 36 33 36 39 30 30 61 33 34 30 35 34 31 39 8d636900a3405419</span><br></pre></td></tr></table></figure><p>看完1189c再通过buffer交叉引用找到ptr，再通过ptr的交叉引用找到md5_update，之前已经找到所有buffer引用的地方，一个是1189c，还有一个11a68，1189c已经分析完了，然后要接着向下分析</p><p>再来看看ptr的交叉引用，没看到引用的函数</p><p><img src="https://s2.loli.net/2022/02/11/KwsEAxG9bBJmOhX.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2016.png"></p><p>再看看v103和v104的交叉引用</p><p><img src="https://s2.loli.net/2022/02/11/XBmMD2HeIJ5LjTc.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2017.png"></p><p>进入sub_11B64函数看下</p><p><img src="https://s2.loli.net/2022/02/11/WM4IFirtgUTvR1w.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2018.png"></p><p>继续写frida脚本，hook sub_11B64</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> sub_11B64 = base_protect.add(<span class="number">0x11B64</span>);</span><br><span class="line"> Interceptor.attach(sub_11B64, &#123;</span><br><span class="line"> onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.arg0 = args[<span class="number">0</span>];</span><br><span class="line"> <span class="built_in">this</span>.arg1 = args[<span class="number">1</span>];</span><br><span class="line"> <span class="built_in">this</span>.arg2 = args[<span class="number">2</span>];</span><br><span class="line"> &#125;,</span><br><span class="line"> onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;sub_11B64 onLeave:\n&quot;</span>, hexdump(<span class="built_in">this</span>.arg1, &#123; <span class="attr">length</span>: <span class="number">0x10</span> &#125;));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>可以看到sub_11B64的a2输出结果和Java层调用qdsc函数的结果一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> [Google Pixel XL::com.qiyi.video]-&gt; call_getQdsc()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> sub_11B64 onLeave:</span><br><span class="line"> </span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF</span><br><span class="line"> </span><br><span class="line"> de51cab0 61 69 04 a6 66 02 56 fa fe f2 db 96 7e b8 28 80 ai..f.V.....~.(.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> qdsc: 616904a6660256fafef2db967eb82880</span><br></pre></td></tr></table></figure><p>此时已经分析出结果</p><p><img src="https://s2.loli.net/2022/02/11/ECkLdVFwunUj4yZ.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2019.png"></p><p>通过hook sub_11a68 也就是md5_update，可以看到多次调用sub_11a68</p><p><img src="https://s2.loli.net/2022/02/11/TDrpVws3auCkge9.png" alt="%E5%88%86%E6%9E%90ollvm%E6%B7%B7%E6%B7%86%E7%9A%84iqiyi%20sign%E7%AE%97%E6%B3%95%20a3693b6ff722425198cd087b55e69b00/Untitled%2020.png"></p><p>qdsc = md5(str + “0n9wdzm8pcyl1obxe0n9qdzm2pcyf1ob”);</p><p>分析被Olllvm混淆的算法的时候，如果IDA能够F5反编译出来，那么按下面的思路来分析算法:</p><p>从参数找交叉引用，通过frida hook使用参数的地方(函数)。</p><p>如果还没分析出算法，再从结果找交叉引用，用frida hook返回结果的地方(函数)进行分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析ollvm混淆的iqiyi-sign算法&quot;&gt;&lt;a href=&quot;#分析ollvm混淆的iqiyi-sign算法&quot; class=&quot;headerlink&quot; title=&quot;分析ollvm混淆的iqiyi sign算法&quot;&gt;&lt;/a&gt;分析ollvm混淆的iqiyi sign</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@编写字符串混淆pass</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass/</id>
    <published>2022-02-11T07:41:37.000Z</published>
    <updated>2022-02-11T07:46:36.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写字符串混淆pass"><a href="#编写字符串混淆pass" class="headerlink" title="编写字符串混淆pass"></a>编写字符串混淆pass</h1><p>字符串混淆pass原理是编译时先混淆，使用前再解混淆</p><p>创建一个StringObf.h</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211u9bAJE.png" alt="Untitled"></p><p>创建一个StringObf.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cddyjm.png" alt="Untitled"></p><p>加入到CMakeLists.txt中 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211h9JTf7.png" alt="Untitled"></p><p>在Entry.cpp中添加StringObf.h并绑定变量</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202110OUQqd.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VQnUNH.png" alt="Untitled"></p><p>此时编译一下项目应该是编译成功的</p><p>创建一个测试文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211z5pPsa.png" alt="Untitled"></p><p>声明环境变量，使用clang编译测试文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fNsMj4.png" alt="Untitled"></p><p>测试文件的IR代码</p><p>@是全局变量的标识</p><p>%是局部的寄存器</p><p>可以看到这个例子里有全局的str，也有%str</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IRyjxY.png" alt="Untitled"></p><p>我们可以先对字符串进行逐位异或加密，再在使用前进行解密</p><p>要先进行加密就要对字符串进行赋值</p><p>写一个测试语句</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211jkm2k7.png" alt="Untitled"></p><p>看下IR中间代码，这里将y保存到下标arrayidx处，arrayidx来自%0的第0个，%0来自字符串数组</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HbZSon.png" alt="Untitled"></p><p>在StringObf.cpp中添加如下代码，先枚举所有基本块，再枚举所有指令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021130sfGH.png" alt="Untitled"></p><p>执行编译，生成pass，使用这个pass编译测试文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -load -Xclang /home/OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -strobf hello_ollvm_7.c -emit-llvm -S -o hello_ollvm_strobf.ll</span><br></pre></td></tr></table></figure><p>指令会在控制台中被打印出来 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202114XfcV3.png" alt="image-20220211154531275"></p><p>打印出每条指令之后再拿到指令里面的值，我们的目标是找@str，所以过滤str字符串</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211XHsbo5.png" alt="Untitled"></p><p>判断是否是一个全局变量，如果是全局变量可以通过判断进入内部逻辑，要找的就是全局变量@str</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211t28aSm.png" alt="Untitled"></p><p>找到全局str，获取到它的值 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211K6WNns.png" alt="image-20220211154546242"></p><p>接着获取到一个异或的值对字符串进行加密 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GDpjny.png" alt="Untitled"></p><p>接着要进行解密，进行解密需要先申请一个数组，为了了解llvm里面的数组是如何申请的，先在源码里申请一个数组然后进行编译看IR指令 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202112Uyic0.png" alt="Untitled"></p><p>alloca[7*i8]里面的7是数组的长度，先创建了一个数组，再通过bitcast拿到它的指针，这个bitcast就是llvm的函数 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211JBz0dT.png" alt="Untitled"></p><p>用AllocaInst创建一个数组，数组的名字随便拼接一个就可以，最后一个参数是插入当前指令之前</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211urQ7Xg.png" alt="Untitled"></p><p>如果不会使用可以在llvm项目里面搜关键字看下用法</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202113grx7e.png" alt="Untitled"></p><p>创建数组在IR指令中是这样的，发现指令不对，还差一个对齐，这样就需要找到AllocaInst另一个API</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zK5VKv.png" alt="Untitled"></p><p>至于有哪些API，在编写代码中点击进行看头文件直接可以看到</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202119OALXV.png" alt="Untitled"></p><p>添加对齐参数，并且使用数组ArrayType</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211o9xO1l.png" alt="Untitled"></p><p>这个时候创建成功</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b34qvc.png" alt="Untitled"></p><p>api使用方法有以下几种：</p><p>1、可以通过在编写源码的时候跳转看api</p><p>2、可以在llvm项目里面搜索关键字看看llvm是怎么用的</p><p>3、llvm官方文档查看使用方法</p><p>接着拿到数组的指针</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202115IR8Vo.png" alt="Untitled"></p><p>再获得字符串数组里面每个下标指针</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117kyNFj.png" alt="Untitled"></p><p>需要注意要调用insertBefore，否则这里就是反顺序的 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111h8Lmn.png" alt="Untitled"></p><p>再添加一个逻辑，把字符串数据保存到刚才创建的数组里 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Zl0wdf.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nVZ5sz.png" alt="Untitled"></p><p>可以把指令的值全部用%.str.bitcast代替</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wBgiXS.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Bneknu.png" alt="Untitled"></p><p>代替前</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211A2dTVe.png" alt="Untitled"></p><p>代替后</p><p><img src="%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B7%E6%B7%86pass%20752ec966d0804194a1abb60834323e3c/Untitled%2032.png" alt="Untitled"></p><p>再加入异或的代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ze6xXj.png" alt="Untitled"></p><p>异或后进行保存</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fXDxHq.png" alt="Untitled"></p><p>要提前保存下异或的key </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211slc3Ze.png" alt="Untitled"></p><p>在使用前进行解密</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116m1D3F.png" alt="Untitled"></p><p>可以看到每次在存储前进行异或解密，这里的xor的key是10进制的98</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211cAHdiK.png" alt="image-20220211154614212"></p><p>这样就无法看到原字符串的值，但是这样的静态反混淆是不够的，完全可以对这些字符进行解密，直接进行异或计算就可以得到原来的字符串</p><p>在优化编译的时候也是可以直接还原的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IuUmt4.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nidHiZ.png" alt="Untitled"></p><p>为了防止被优化，需要创建个变量进行中转</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211e1DN1D.png" alt="Untitled"></p><p>将把key保存到另一个变量，再取出，最后使用这个变量进行操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202110YHyqK.png" alt="Untitled"></p><p>可以看到这里是对%0进行操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111AppLq.png" alt="image-20220211154627516"></p><p>平坦化结合字符串加密</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tGnOXT.png" alt="Untitled"></p><p>虽然这样增加了逆向的难度，这里的字符串也被分割成了字符，而且无法一眼看出原字符串</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gL1tIF.png" alt="Untitled"></p><p>在汇编视图可以看到xor指令，这样还是可以还原字符串，只是过程比较繁琐 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211rq4cms.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写字符串混淆pass&quot;&gt;&lt;a href=&quot;#编写字符串混淆pass&quot; class=&quot;headerlink&quot; title=&quot;编写字符串混淆pass&quot;&gt;&lt;/a&gt;编写字符串混淆pass&lt;/h1&gt;&lt;p&gt;字符串混淆pass原理是编译时先混淆，使用前再解混淆&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@函数名加密pass</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86pass/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E5%87%BD%E6%95%B0%E5%90%8D%E5%8A%A0%E5%AF%86pass/</id>
    <published>2022-02-11T07:40:37.000Z</published>
    <updated>2022-02-11T07:40:53.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数名加密pass"><a href="#函数名加密pass" class="headerlink" title="函数名加密pass"></a>函数名加密pass</h1><p>在Transforms下面创建EncodeFunctionName目录，创建一个EncodeFunctionName.cpp文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211iOaOmt.png" alt="Untitled"></p><p>创建下图中的几个文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211IaLr3T.png" alt="Untitled"></p><p>Reload CMake Project</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211OiWHES.png" alt="Untitled"></p><p>把新创建的pass添加到Transforms目录下的CMakeLists.txt文件中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gBp2w7.png" alt="Untitled"></p><p>然后在EncodeFunctionName.cpp中添加头文件和命名空间</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211uj4gYq.png" alt="Untitled"></p><p>然后根据官方文档把下面的代码添加上去</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pyGKbU.png" alt="Untitled"></p><p>进入cmake-build-release目录，直接单独编译这个模块 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211O3gnpL.png" alt="Untitled"></p><p>找到pass路径</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HdJCgu.png" alt="Untitled"></p><p>通过pass对ll文件进行处理生成bc文件，可以看到pass文件里面的语句被执行了，pass成功编译进去了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zyNbSL.png" alt="Untitled"></p><p>对函数名进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211i027Xc.png" alt="Untitled"></p><p>运行时函数名还是原来的，只是静态反编译的情况下会被混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fHCuPS.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数名加密pass&quot;&gt;&lt;a href=&quot;#函数名加密pass&quot; class=&quot;headerlink&quot; title=&quot;函数名加密pass&quot;&gt;&lt;/a&gt;函数名加密pass&lt;/h1&gt;&lt;p&gt;在Transforms下面创建EncodeFunctionName目录，创建一个En</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@OLLVM的几种混淆方法</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-11T07:38:37.000Z</published>
    <updated>2022-02-11T07:38:53.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM的几种混淆方法"><a href="#OLLVM的几种混淆方法" class="headerlink" title="OLLVM的几种混淆方法"></a>OLLVM的几种混淆方法</h1><h2 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h2><p>写一个小程序进行测试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211kq8mx4.png" alt="Untitled"></p><p>导出环境变量，然后使用ollvm进行指令替换</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=<span class="regexp">/home/</span>ollvm/llvm-project-<span class="number">9.0</span><span class="number">.1</span>/llvm/cmake-build-release/bin:$PATH</span><br><span class="line">clang -mllvm -sub hello_ollvm.c -o hello_ollvm</span><br></pre></td></tr></table></figure><p>这是原版的 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117QDGLy.png" alt="Untitled"></p><p>这是经过ollvm指令替换的</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211dDh3qJ.png" alt="Untitled"></p><h2 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h2><p>通过添加虚假的控制流程来实现混淆 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf hello_ollvm_bcf.c -o hello_ollvm_bcf</span><br></pre></td></tr></table></figure><p>其实它只会执行某一个地方，绝大多数的位置都不会执行</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116jg8yf.png" alt="Untitled"></p><h2 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h2><p>平坦化效果，通常有大量的while循环</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yOQoyR.png" alt="Untitled"></p><p>执行平坦化指令</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla hello_ollvm_fla.c -o hello_ollvm_fla</span><br></pre></td></tr></table></figure><p>平坦化效果</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211LSSV4t.png" alt="Untitled"></p><p>指定函数平坦化混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211ZfpTLA.png" alt="Untitled"></p><p>指定函数不混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211h0q4Nt.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM的几种混淆方法&quot;&gt;&lt;a href=&quot;#OLLVM的几种混淆方法&quot; class=&quot;headerlink&quot; title=&quot;OLLVM的几种混淆方法&quot;&gt;&lt;/a&gt;OLLVM的几种混淆方法&lt;/h1&gt;&lt;h2 id=&quot;指令替换&quot;&gt;&lt;a href=&quot;#指令替换&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@移植OLLVM到NDK中</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0NDK%E4%B8%AD/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0NDK%E4%B8%AD/</id>
    <published>2022-02-11T07:35:37.000Z</published>
    <updated>2022-02-11T07:37:18.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移植OLLVM到NDK中"><a href="#移植OLLVM到NDK中" class="headerlink" title="移植OLLVM到NDK中"></a>移植OLLVM到NDK中</h1><p>进入llvm目录，复制三个目录到NDK的linux-x86_64目录下，覆盖掉</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211YC0w65.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211y1T1CQ.png" alt="Untitled"></p><p>创建个c++项目</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116vpkRu.png" alt="Untitled"></p><p>默认的项目会使用自带的NDK，有的时候我们需要使用下载下来的ndk，只要在配置文件里指定一下ndk的目录就可以了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211591BRt.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NoXyzy.png" alt="Untitled"></p><p>添加ollvm声明，编译时会加入这些参数 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GQ2qqr.png" alt="image-20220211153712292"></p><p>写一个示例代码，太简单的话基本块很少，没法分割进行混淆</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211xG3YYm.png" alt="Untitled"></p><p>编译成汇编</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211SJgBpL.png" alt="Untitled"></p><p>生成的在下面的目录里面</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116eynt1.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bKmHt0.png" alt="Untitled"></p><p>可以看到代码已经被混淆了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202118EP3h1.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移植OLLVM到NDK中&quot;&gt;&lt;a href=&quot;#移植OLLVM到NDK中&quot; class=&quot;headerlink&quot; title=&quot;移植OLLVM到NDK中&quot;&gt;&lt;/a&gt;移植OLLVM到NDK中&lt;/h1&gt;&lt;p&gt;进入llvm目录，复制三个目录到NDK的linux-x86_</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@移植OLLVM到单独的so</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0%E5%8D%95%E7%8B%AC%E7%9A%84so/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@%E7%A7%BB%E6%A4%8DOLLVM%E5%88%B0%E5%8D%95%E7%8B%AC%E7%9A%84so/</id>
    <published>2022-02-11T07:30:37.000Z</published>
    <updated>2022-02-11T07:34:25.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移植OLLVM到单独的so"><a href="#移植OLLVM到单独的so" class="headerlink" title="移植OLLVM到单独的so"></a>移植OLLVM到单独的so</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>移植到单独的so，这样修改OLLVM就不用编译整个LLVM代码</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211YMpm31.png" alt="Untitled"></p><h2 id="ollvm目录"><a href="#ollvm目录" class="headerlink" title="ollvm目录"></a>ollvm目录</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211NsUh5v.png" alt="Untitled"></p><p>include目录下的结构</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nvHsTY.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021172bFcm.png" alt="Untitled"></p><p>lib目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Gzru9L.png" alt="Untitled"></p><p>lib目录下的CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211zMGlhd.png" alt="Untitled"></p><p>lib目录下的LLVMBuild.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211OL3X5P.png" alt="Untitled"></p><p>lib/Transforms目录下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ut70Tf.png" alt="Untitled"></p><p>lib/Transforms目录下的CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gT4jnD.png" alt="Untitled"></p><p>lib/Transforms目录下的LLVMBuild.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211vjmXnQ.png" alt="Untitled"></p><p>lib/Transforms目录下的Obfuscation目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211AXPl9G.png" alt="image-20220211153136224"></p><p>CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021197F1Ih.png" alt="image-20220211153148520"></p><h2 id="根目录下CMakeLists-txt"><a href="#根目录下CMakeLists-txt" class="headerlink" title="根目录下CMakeLists.txt"></a>根目录下CMakeLists.txt</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tuw8a4.png" alt="image-20220211153155749"></p><h2 id="用CLion进行编译"><a href="#用CLion进行编译" class="headerlink" title="用CLion进行编译"></a>用CLion进行编译</h2><p>只留下build版本，进行编译，生成了libLLVMObfuscation.a文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211jjWyAh.png" alt="image-20220211153209328"></p><p>给Obfuscation目录下的CMakeLists.txt文件添加一个MODULE标志 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211kwd393.png" alt="image-20220211153219001"></p><p>这时会生成一个LLVMObfuscation.so文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211a18OUC.png" alt="image-20220211153239858"></p><p>ollvm是通过在PassManagerBuilder.cpp中注册绑定参数</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211oga8TT.png" alt="image-20220211153247761"></p><p>在lib/Transforms/Obfuscation目录下创建Entry.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211dwTVBJ.png" alt="image-20220211153301860"></p><p>把Entry.cpp放到Obfuscation目录下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021136vHl8.png" alt="image-20220211153309077"></p><p>添加命名空间</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ivsfsp.png" alt="image-20220211153315511"></p><p>添加额外的头文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211UgxZBs.png" alt="image-20220211153322135"></p><p>最后进行注册</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211HJ1dHE.png" alt="image-20220211153329285"></p><p>找到之前编译的clang的路径</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211lVE29w.png" alt="image-20220211153336825"></p><p>Program arguments填入下面的参数，编译生成ll文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xclang -load -Xclang /OLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -fla /home/hello_ollvm_fla.c -emit-llvm -S -o /home/hello_ollvm_fla.ll</span><br></pre></td></tr></table></figure><h2 id="调试ollvm"><a href="#调试ollvm" class="headerlink" title="调试ollvm"></a>调试ollvm</h2><p>也可以下断点进行调试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211vxRnIZ.png" alt="image-20220211153344796"></p><p>断点没有断下来，执行一个异常看下代码有没有被执行</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VT7iPq.png" alt="image-20220211153352097"></p><p>程序崩溃，看到个clang-9，这条指令是真正的编译指令 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211K0Ftkp.png" alt="image-20220211153400066"></p><p>看下这个clang工具，发现它有个软链接指向了clang-9</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211amfy2Q.png" alt="image-20220211153407036"></p><p>把clang-9的参数拷贝过来，选择clang-9程序</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sTwiUV.png" alt="image-20220211153413647"></p><p>再重新下断点并调试，这时程序正常断下了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211bl2joT.png" alt="image-20220211153420188"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;移植OLLVM到单独的so&quot;&gt;&lt;a href=&quot;#移植OLLVM到单独的so&quot; class=&quot;headerlink&quot; title=&quot;移植OLLVM到单独的so&quot;&gt;&lt;/a&gt;移植OLLVM到单独的so&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@OLLVM移植到新版本LLVM</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%A7%BB%E6%A4%8D%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%ACLLVM/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@OLLVM%E7%A7%BB%E6%A4%8D%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%ACLLVM/</id>
    <published>2022-02-11T07:25:37.000Z</published>
    <updated>2022-02-11T07:26:27.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLLVM移植到新版本LLVM"><a href="#OLLVM移植到新版本LLVM" class="headerlink" title="OLLVM移植到新版本LLVM"></a>OLLVM移植到新版本LLVM</h1><p>由于OLLVM已经好几年没有更新了，最近的更新还是基于LLVM4.0的</p><p>进入ollvm github仓库查看文件可以看到修改的位置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211t33Jkn.png" alt="Untitled"></p><p>下载ollvm</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nxMT6F.png" alt="Untitled"></p><p>切换到llvm-4.0分支</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Kk1CrI.png" alt="Untitled"></p><p>把Obfuscation目录复制到llvm的Transforms目录下 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211pVXCy6.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Hd5Qb8.png" alt="Untitled"></p><p>修改Transforms/CMakeLists.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211XKN0eh.png" alt="Untitled"></p><p>修改Transform/LLVMBuild.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mhJCkz.png" alt="Untitled"></p><p>进入IPO目录，找到PassManagerBuilder.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hZ8ijP.png" alt="Untitled"></p><p>如果路径下的文件不存在，把文件拷贝到路径下就可以了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Nvg1AQ.png" alt="Untitled"></p><p>可以通过查看github上面的文件修改历史知道做了哪些改动</p><p>PassManagerBuilder.cpp还添加了下面的代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211n3ZKG3.png" alt="Untitled"></p><p>初始化了AesSeed，这些代码都是LLVM没有的，在移植过去的时候需要添加，另外还有一些简单的改动文件，移植的时候注意下就可以了，这里就不一一截图了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wAGPfj.png" alt="Untitled"></p><p>修改好了以后就可以用ninja LLVMObfuscation编译OLLVM了 </p><p>OLLVM有些bug被修复了，根据这些修改对文件进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211PHJN23.png" alt="Untitled"></p><p>使用ninja clang指令进行编译，如果顺利就移植成功了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLLVM移植到新版本LLVM&quot;&gt;&lt;a href=&quot;#OLLVM移植到新版本LLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM移植到新版本LLVM&quot;&gt;&lt;/a&gt;OLLVM移植到新版本LLVM&lt;/h1&gt;&lt;p&gt;由于OLLVM已经好几年没有更新了，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@pass基本使用</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-11T07:19:37.000Z</published>
    <updated>2022-02-11T07:21:50.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pass基本使用"><a href="#pass基本使用" class="headerlink" title="pass基本使用"></a>pass基本使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>pass是LLVM里面重要的框架，不同的pass用于源代码在编译之前进行优化，可以复杂化也可以简单化，ollvm就是pass的一种</p><p>下图对bc文件执行了pass，bc文件是机器语言，但是通过—print-bb这个pass，可以打印中间代码</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211u3Xq8m.png" alt="Untitled"></p><p>每个pass都会调用runOnFunction函数，可以对要处理的函数进行修改</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211nsZXyP.png" alt="Untitled"></p><h2 id="pass使用方法"><a href="#pass使用方法" class="headerlink" title="pass使用方法"></a>pass使用方法</h2><p>pass在llvm根目录下lib文件夹的Transforms文件夹中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211j9yz7h.png" alt="Untitled"></p><p>在进行编译时,目标程序的函数都会传递给runOnFunction函数，这个pass只是打印了函数的名字</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Ksp67O.png" alt="Untitled"></p><p>查看这个pass的CMakeLists.txt文件，添加opt，那么就会生成对应的so文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202116LgN3m.png" alt="Untitled"></p><p>生成的pass名字是LLVMHello.so</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211xho6og.png" alt="Untitled"></p><p>下图是使用自定义pass的命令，-hello是自定义pass定义的参数，可以看到这个pass的功能是打印了一个函数名称main</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fPzoLR.png" alt="Untitled"></p><p>再给C文件添加个函数test_hello1</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Uupk4q.png" alt="Untitled"></p><p>hello.clang.ll还存在一些外部的函数，比如说printf，它不受pass影响，所以这个函数名没有打印出来，pass只能优化我们自己写的代码 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Wao4vg.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pass基本使用&quot;&gt;&lt;a href=&quot;#pass基本使用&quot; class=&quot;headerlink&quot; title=&quot;pass基本使用&quot;&gt;&lt;/a&gt;pass基本使用&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@LLVM基础：编译、调试、工具</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@LLVM%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E8%B0%83%E8%AF%95%E3%80%81%E5%B7%A5%E5%85%B7/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@LLVM%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E8%B0%83%E8%AF%95%E3%80%81%E5%B7%A5%E5%85%B7/</id>
    <published>2022-02-11T07:15:37.000Z</published>
    <updated>2022-02-11T07:21:40.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLVM基础：编译、调试、工具"><a href="#LLVM基础：编译、调试、工具" class="headerlink" title="LLVM基础：编译、调试、工具"></a>LLVM基础：编译、调试、工具</h1><h2 id="LLVM简介"><a href="#LLVM简介" class="headerlink" title="LLVM简介"></a>LLVM简介</h2><p>LLVM包含了很多项目 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211AkfVtX.png" alt="Untitled"></p><h2 id="llvm下载"><a href="#llvm下载" class="headerlink" title="llvm下载"></a>llvm下载</h2><p>ndk的llvm/bin目录下，有llvm套件，可以查看这些工具的版本，然后在llvm官网下载相近的版本就可以了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clang --version</span><br></pre></td></tr></table></figure><p>llvm源码目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202117mMtGq.png" alt="Untitled"></p><h2 id="llvm编译"><a href="#llvm编译" class="headerlink" title="llvm编译"></a>llvm编译</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>进入llvm.org/docs找到llvm文档，按照文档中环境要求进行安装和配置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211GIDrhI.png" alt="Untitled"></p><p>有个方便的做法是把安卓源码依赖的程序全部安装上，这样基本就满足了llvm编译的环境要求了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211M7Syja.png" alt="Untitled"></p><h3 id="编译debug版本"><a href="#编译debug版本" class="headerlink" title="编译debug版本"></a>编译debug版本</h3><p>进入llvm根目录创建build_debug目录并进入该目录，执行下面的命令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211mgCSNc.png" alt="Untitled"></p><p>然后再执行ninja -j8命令</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Q8e6Tn.png" alt="Untitled"></p><h3 id="编译release版本"><a href="#编译release版本" class="headerlink" title="编译release版本"></a>编译release版本</h3><p>在根目录下创建build_release目录并进入这个目录下，执行下面的命令</p><p>-DLLVM_ENABLE_PROJECTS=”clang”的意思添加编译clang程序，这样生成的bin目录下就有clang的可执行程序了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b015uU.png" alt="Untitled"></p><h3 id="使用CLion进行编译"><a href="#使用CLion进行编译" class="headerlink" title="使用CLion进行编译"></a>使用CLion进行编译</h3><p>打开项目，路径选择根目录llvm目录下的CMakeLists.txt文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yros28.png" alt="Untitled"></p><p>进入设置，指定编译选项</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211JMuA3C.png" alt="Untitled"></p><p>点击确定之后项目会自动进行build</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211uKw8bl.png" alt="Untitled"></p><p>关闭CLion，进入命令行执行ninja -j8进行编译 </p><p>可以给CLion增加内存</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211QlkRNp.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wC6Esy.png" alt="Untitled"></p><p>也可以进入cmake-build-debug目录单独编译某一个项目，比如说clang</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211yHWUtS.png" alt="Untitled"></p><h2 id="测试编译的Clang程序"><a href="#测试编译的Clang程序" class="headerlink" title="测试编译的Clang程序"></a>测试编译的Clang程序</h2><p>写一个简单的C文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sBvRcw.png" alt="Untitled"></p><p>控制台添加刚编译的clang程序的环境变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=<span class="regexp">/home/</span>ollvm/llvm-project-<span class="number">9.0</span><span class="number">.1</span>/llvm/cmake-build-debug/bin:$PATH</span><br></pre></td></tr></table></figure><p>使用clang对C文件进行编译并运行 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang hello_clang.c -o hello_clang</span><br><span class="line">./hello_clang</span><br></pre></td></tr></table></figure><h2 id="调试编译的Clang程序"><a href="#调试编译的Clang程序" class="headerlink" title="调试编译的Clang程序"></a>调试编译的Clang程序</h2><p>找到clang程序  </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hD618k.png" alt="Untitled"></p><p>设置路径为刚才编辑的c文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b85gdL.png" alt="Untitled"></p><p>点击确定后，目录下生成了一个可执行文件hello_clang_clion</p><p>然后找到clang目录下的tools里面的driver.cpp</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211lWnJdN.png" alt="Untitled"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gEg0ov.png" alt="Untitled"></p><p>在main函数下断点就可以对clang进行调试了 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202113lBfwn.png" alt="Untitled"></p><h2 id="调试opt程序"><a href="#调试opt程序" class="headerlink" title="调试opt程序"></a>调试opt程序</h2><p>找到opt，然后进入配置</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sf5Tbi.png" alt="Untitled"></p><p>把下图的参数填入Program arguments中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Xvz3xM.png" alt="Untitled"></p><p>hello_clang.dll文件路径需要修改为绝对路径，如果程序无法运行，可以把so文件路径的单引号去掉试试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211ze7uCf.png" alt="Untitled"></p><p>opt工具在tools文件夹下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211sD4R2X.png" alt="Untitled"></p><p>然后在main函数中下断，之后就可以进行调试了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211T9Af1l.png" alt="Untitled"></p><p>中间文件的源文件也可以下断点进行调试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211J7A1z7.png" alt="Untitled"></p><h2 id="llvm工具"><a href="#llvm工具" class="headerlink" title="llvm工具"></a>llvm工具</h2><h3 id="编译中间语言"><a href="#编译中间语言" class="headerlink" title="编译中间语言"></a>编译中间语言</h3><p>编译成中间语言，中间语言可以转为不同平台的汇编语言</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S hello_clang.c -o hello_clang.ll</span><br></pre></td></tr></table></figure><p>生成的ll文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Lri4fu.png" alt="Untitled"></p><p>中间语言文件一样可以被执行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lli hello_clang.ll</span><br></pre></td></tr></table></figure><h3 id="llvm-as工具"><a href="#llvm-as工具" class="headerlink" title="llvm-as工具"></a>llvm-as工具</h3><p>转为汇编之前要先转为bitcode文件，通过llvm-as工具完成</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-<span class="keyword">as</span> hello_clang.ll -o hello_clang.bc</span><br></pre></td></tr></table></figure><h3 id="llc工具"><a href="#llc工具" class="headerlink" title="llc工具"></a>llc工具</h3><p>通过llc工具把bitcode文件转为汇编文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello_clang.bc -o hello_clang.s</span><br></pre></td></tr></table></figure><h3 id="llvm-dis工具"><a href="#llvm-dis工具" class="headerlink" title="llvm-dis工具"></a>llvm-dis工具</h3><p>通过llvm-dis工具将bitcode文件转为中间文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis hello_clang.bc -o hello_clang_re.ll</span><br></pre></td></tr></table></figure><h3 id="opt工具"><a href="#opt工具" class="headerlink" title="opt工具"></a>opt工具</h3><p>opt工具主要的作用有两个：</p><ul><li>查看bitcode文件</li><li>对bc文件或ll文件执行pass</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLVM基础：编译、调试、工具&quot;&gt;&lt;a href=&quot;#LLVM基础：编译、调试、工具&quot; class=&quot;headerlink&quot; title=&quot;LLVM基础：编译、调试、工具&quot;&gt;&lt;/a&gt;LLVM基础：编译、调试、工具&lt;/h1&gt;&lt;h2 id=&quot;LLVM简介&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组加密算法的的填充模式和工作模式</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-11T07:12:37.000Z</published>
    <updated>2022-02-11T07:12:45.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组加密算法的的填充模式和工作模式"><a href="#分组加密算法的的填充模式和工作模式" class="headerlink" title="分组加密算法的的填充模式和工作模式"></a>分组加密算法的的填充模式和工作模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分组密码分别支持的工作模式和填充模式</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211iFK4Nh.png" alt="%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2078d599c8de674cdab241a48fbd86e55f/Untitled.png"></p><h2 id="分组密码的填充模式"><a href="#分组密码的填充模式" class="headerlink" title="分组密码的填充模式"></a>分组密码的填充模式</h2><p>明文长度不够一个分组时：对不够一个分组大小时，制定一定的标准进行填充，使加密内容的长度到达一个分组大小；在解密时按照相同的标准再将填充部分删掉即可。有时，对于恰好已经是一个明文长度的分组也会填充，这时就会填充一个新的分组。</p><h2 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h2><p>即对每一个明文分组加密的方式，主要有以下几种：</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211o9zTeF.png" alt="%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%2078d599c8de674cdab241a48fbd86e55f/Untitled%201.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组加密算法的的填充模式和工作模式&quot;&gt;&lt;a href=&quot;#分组加密算法的的填充模式和工作模式&quot; class=&quot;headerlink&quot; title=&quot;分组加密算法的的填充模式和工作模式&quot;&gt;&lt;/a&gt;分组加密算法的的填充模式和工作模式&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组密码之AES</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES/</id>
    <published>2022-02-11T07:10:37.000Z</published>
    <updated>2022-02-11T07:11:41.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组密码之AES"><a href="#分组密码之AES" class="headerlink" title="分组密码之AES"></a>分组密码之AES</h1><p>以AES-128为例，会对明文分组进行10轮迭代运算，加密的第1轮到第9轮的轮函数一样，包括4个操作：字节替换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111r6VS2.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES%208f5210e1a4174f6a8f8795491ae7e026/Untitled.png"></p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211woepIT.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BAES%208f5210e1a4174f6a8f8795491ae7e026/Untitled%201.png"></p><p>字节代替：字节代替的主要是通过s盒完成一个字节到另一个字节的映射</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Lldjvz.png" alt="Untitled"></p><p>行位移：第一行保持不变，第二行循环左移1个字节，第三行循环左移2个字节，第四行循环左移3个字节 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211b5UQNG.png" alt="Untitled"></p><p>列混淆：主要用于提供AES算法的扩散性，对列混淆矩阵相乘得到结果</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211D1a67h.png" alt="Untitled"></p><p>轮密钥加：每轮的输入与轮密钥异或一次（当前分组和扩展密钥的一部分进行按位异或），因为二进制连续异或一个数结果是不变的，所以在解密时再异或该密钥就可恢复</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组密码之AES&quot;&gt;&lt;a href=&quot;#分组密码之AES&quot; class=&quot;headerlink&quot; title=&quot;分组密码之AES&quot;&gt;&lt;/a&gt;分组密码之AES&lt;/h1&gt;&lt;p&gt;以AES-128为例，会对明文分组进行10轮迭代运算，加密的第1轮到第9轮的轮函数一样，包括</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@分组密码之DES</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES/</id>
    <published>2022-02-11T07:09:37.000Z</published>
    <updated>2022-02-11T07:09:27.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组密码之DES"><a href="#分组密码之DES" class="headerlink" title="分组密码之DES"></a>分组密码之DES</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DES算法会将明文按64位进行分组，密钥长64位，其中有56位参与DES运算，其余的几位是检验位，分组后的明文会跟56位密钥进行按位替代或交换形成密文</p><p>每次加密会对64位明文进行16轮编码，每一轮都会用密钥生成的子密钥进行运算</p><p>DES主要的处理过程分为两部分，首先是密钥的生成，然后是明文的处理</p><p><img src="https://s2.loli.net/2022/02/11/mEyAYxR1QSb4Bhu.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled.png"></p><h2 id="DES算法中出现的常量表"><a href="#DES算法中出现的常量表" class="headerlink" title="DES算法中出现的常量表"></a>DES算法中出现的常量表</h2><p>在对每一个64位明文分组进行处理的过程中，有大量常量表参与，从而完成对明文的混淆、扩散等处理。主要常量表有：初始置换表、逆初始置换表、扩展置换E表、8个s-box，这些常量都是快速判断DES算法的标志</p><p><img src="https://s2.loli.net/2022/02/11/hSwx82KXNmYZLzo.png" alt="Untitled"></p><p>在针对明文分组16轮处理过程中，每一轮都需要一个由原始56位密钥经过编排生成的48位子密钥的参与，这个过程中也出现了一些常量表，主要有：初始置换PC-1表、PC-2表</p><p><img src="https://s2.loli.net/2022/02/11/EcxWTZ5LNCmt36J.png" alt="Untitled"></p><h2 id="双重DES和三重DES"><a href="#双重DES和三重DES" class="headerlink" title="双重DES和三重DES"></a>双重DES和三重DES</h2><p>双重DES就是首先用key1对明文进行加密得到加密字符串，再用key2对加密字符串再进行加密得到最终加密字符串</p><p>三重DES是类似的概念，只是加密多加了一轮</p><h2 id="Java中使用DES加密"><a href="#Java中使用DES加密" class="headerlink" title="Java中使用DES加密"></a>Java中使用DES加密</h2><p>Java中使用DES算法</p><p><img src="https://s2.loli.net/2022/02/11/lKZ1G2kadeSUWy9.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%203.png"></p><p>iv是初始化向量参数</p><p>PKCS5Padding表示分组的填充方式</p><p><img src="https://s2.loli.net/2022/02/11/1PwoyYEqrcHkQ4p.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%204.png"></p><h2 id="对DES加密进行hook"><a href="#对DES加密进行hook" class="headerlink" title="对DES加密进行hook"></a>对DES加密进行hook</h2><p>下面有些函数需要重载</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Java.use(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).getInstance.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg0</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.getInstance is called!&#x27;</span>,arg0);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">this</span>.getInstance(arg0);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        Java.use(<span class="string">&#x27;javax.crypto.Cipher&#x27;</span>).init.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">arg0,arg1,arg2</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>,arg0,arg1,arg2);</span><br><span class="line">            <span class="keyword">var</span> mode = arg0;</span><br><span class="line">            <span class="keyword">var</span> key = arg1;</span><br><span class="line">            <span class="keyword">var</span> iv = arg2;</span><br><span class="line">            <span class="keyword">var</span> key_bytes = key.getEncoded();</span><br><span class="line">            <span class="keyword">var</span> iv_bytes = iv.getIV();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;javax.crypto.Cipher.init is called!&#x27;</span>,mode,key_bytes,iv_bytes);</span><br><span class="line">            <span class="keyword">var</span> result = <span class="built_in">this</span>.init(arg0,arg1,arg2);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES的识别"><a href="#DES的识别" class="headerlink" title="DES的识别"></a>DES的识别</h2><p>可以使用findcrypt3进行识别 ，这个插件通过识别常量来判断有没有加密，是哪种加密</p><p><img src="https://s2.loli.net/2022/02/11/NUj3snxCvqMDBip.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%205.png"></p><p>所以我们也可以自己写规则，用来识别加密算法，现在很多用的都不是标准DES的S盒，因此标准DES反而识别不出来，需要自己写规则识别</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211MIt04G.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%206.png"></p><p>另外，可以在IDA中搜E_table这样的字符串，然后把字符串的值填到规则里面</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211fEFP48.png" alt="%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B9%8BDES%201e6af285bea940e0a60f26ecade3ae13/Untitled%207.png"></p><p>当然也可以通过hook api查看DES加密函数有没有被调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组密码之DES&quot;&gt;&lt;a href=&quot;#分组密码之DES&quot; class=&quot;headerlink&quot; title=&quot;分组密码之DES&quot;&gt;&lt;/a&gt;分组密码之DES&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@RC4算法</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@RC4%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@RC4%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-11T07:00:37.000Z</published>
    <updated>2022-02-11T07:00:52.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RC4算法主要有两个算法构成，一个是初始化算法（KSA），还有一个是伪随机子密码生成算法（PRGA）</p><p><img src="https://s2.loli.net/2022/02/11/sg2PYmUJLtMQfkA.png" alt="Untitled"></p><p>KSA算法部分，参数1是一个长度为256的char数组，参数2是密钥，可以任意定义，参数3是密钥的长度，密钥的主要功能是将s-box打乱</p><p><img src="https://s2.loli.net/2022/02/11/hYlXEuRKs2q8cez.png" alt="Untitled"></p><p>PRGA算法，参数1是被打乱的s-box，参数2是需要加密的数据</p><p><img src="https://s2.loli.net/2022/02/11/Z1xzkGXUrbIfYn5.png" alt="Untitled"></p><h2 id="RC4加密算法的识别"><a href="#RC4加密算法的识别" class="headerlink" title="RC4加密算法的识别"></a>RC4加密算法的识别</h2><p>1、RC4算法加密的字符串有一个特点，明文和密文长度相等</p><p>2、逆向算法，找到KSA算法，有两轮非常明显的长度为256的循环体</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RC4算法&quot;&gt;&lt;a href=&quot;#RC4算法&quot; class=&quot;headerlink&quot; title=&quot;RC4算法&quot;&gt;&lt;/a&gt;RC4算法&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@HMAC算法逆向与还原</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@HMAC%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@HMAC%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/</id>
    <published>2022-02-11T06:57:37.000Z</published>
    <updated>2022-02-11T06:58:04.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HMAC算法逆向与还原"><a href="#HMAC算法逆向与还原" class="headerlink" title="HMAC算法逆向与还原"></a>HMAC算法逆向与还原</h1><h2 id="HMAC算法还原"><a href="#HMAC算法还原" class="headerlink" title="HMAC算法还原"></a>HMAC算法还原</h2><p>HMAC有一个key，并且可以选择多种不同的哈希算法</p><p>目标程序对字符串进行加密，算法是HMAC</p><p><img src="https://s2.loli.net/2022/02/11/dwgu7GhSn4RkxEV.png" alt="Untitled"></p><p>核心加密函数，传递了一个字符串kanxue_imyang</p><p><img src="https://s2.loli.net/2022/02/11/Z728GloLjqYsNn4.png" alt="Untitled"></p><p>翻算法找到常量</p><p><img src="https://s2.loli.net/2022/02/11/vpjFLcUTuQ4Y6rC.png" alt="Untitled"></p><p>然后google搜到算法源码，根据源码可以知道这个函数是md5_transform</p><p><img src="https://s2.loli.net/2022/02/11/tA7gdIKsjTu864M.png" alt="Untitled"></p><p>它的上级函数是md5_update</p><p><img src="https://s2.loli.net/2022/02/11/MJke5gPATpEUcKu.png" alt="Untitled"></p><p>地址是0xaf84</p><p><img src="https://s2.loli.net/2022/02/11/CURcih9sAHrJV6y.png" alt="Untitled"></p><p>对md5_update函数进行hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    var base_native_lib = Module.findBaseAddress(<span class="string">&quot;libnative-lib.so&quot;</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;base_native_lib address:&quot;</span>,base_native_lib);</span><br><span class="line">    var md5_update = base_native_lib.add(<span class="number">0xAF84</span> + <span class="number">1</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;md5_update address:&quot;</span>,md5_update);</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(md5_update,&#123;</span><br><span class="line">        onEnter : function(args)&#123;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;md5_update:&quot;</span>,hexdump(args[<span class="number">1</span>],&#123;length : parseInt(args[<span class="number">2</span>])&#125;),args[<span class="number">0</span>]);</span><br><span class="line">        &#125;,onLeave : function(retval)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(test,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>每次加密都会调用8次md5_update函数 </p><p><img src="https://s2.loli.net/2022/02/11/YQLyX6a9t3RF45H.png" alt="Untitled"></p><p>打印一下md5_update调用堆栈，大部分上层函数都指向了0xb738</p><p>接着hook sub_b738</p><p><img src="https://s2.loli.net/2022/02/11/j8BO6CbxMVthdSy.png" alt="Untitled"></p><p>hexdump打印一下sub_b738的内存，可以看到sub_b738的参数的值，每次执行算法时都会调用两次sub_b738函数 </p><p><img src="https://s2.loli.net/2022/02/11/dDt1RmsvX2nFQT7.png" alt="Untitled"></p><p>第二次</p><p><img src="https://s2.loli.net/2022/02/11/5VeKRdbH2oUh3XD.png" alt="Untitled"></p><p>把上面两次md5_update传递的字符串进行拼接再进行md5运算，结果跟第二次调用sub_b738时的第一个参数是一致的</p><p><img src="https://s2.loli.net/2022/02/11/IRm2HQk93UxGq6E.png" alt="Untitled"></p><p>hook最上级函数sub_b9f4，在OnLeave的时候看下传出来的值</p><p><img src="https://s2.loli.net/2022/02/11/1Tce3rpG9luvRE7.png" alt="Untitled"></p><p>hook这几个参数发现跟ida的反编译结果不太一样，根据打印的值猜测前面是字符串，后面是长度</p><p><img src="https://s2.loli.net/2022/02/11/hNYUayKuIRsAEzD.png" alt="Untitled"></p><p>所以可以打印3组数据 </p><p><img src="https://s2.loli.net/2022/02/11/VQLJuh1ti7w4Co2.png" alt="Untitled"></p><p>第一组数据是4e704c….</p><p>第二组数据是kanxue_imyang</p><p>第三组数据是4498220e，这个字符串跟加密的字符串是一致的</p><p><img src="https://s2.loli.net/2022/02/11/XmuliQHvAbhItFR.png" alt="Untitled"></p><p>所以最后一个参数应该就是加密的字符串了</p><p><img src="https://s2.loli.net/2022/02/11/kFKogC7WayQZrOR.png" alt="Untitled"></p><p>进入sub_b9f4函数可以看到result_buffer调用的地方</p><p><img src="https://s2.loli.net/2022/02/11/y9vEBGsSfHdVihu.png" alt="Untitled"></p><p>接着hook sub_b738，此时对应的加密字符串是82900068….</p><p>进入sub_b738时</p><p><img src="https://s2.loli.net/2022/02/11/fPXLdhk2BzH6ulA.png" alt="Untitled"></p><p>可以看到进入sub_b738函数前，有两次md5_update，第二次md5_update的值跟sub_b738第一个参数是一样的</p><p><img src="https://s2.loli.net/2022/02/11/MTR7XH3SApqt2fK.png" alt="Untitled"></p><p>把这两次md5_update传递的字符串拼接到一起然后进入md5运算，得到的值就是最终的加密字符串了</p><p><img src="https://s2.loli.net/2022/02/11/y8AHCUlsf6zeQL2.png" alt="Untitled"></p><p>在sub_b738函数内部又执行了两次md5_update</p><p><img src="https://s2.loli.net/2022/02/11/8twiFBpXHQ5jOKA.png" alt="Untitled"></p><p>执行完sub_b738时，可以看到执行完时就已经是加密后的字符串了</p><p><img src="https://s2.loli.net/2022/02/11/9Z7Ngn3wtxuFzyi.png" alt="Untitled"></p><p>两次md5_update然后执行sub_b738，这两次md5_update拼接的值是最终加密的字符串，在sub_b738内部又调用了两次md5_update，然后执行完毕，加密完成</p><p>其实源字符串通过hmac加密,key设置为kanxue_imyang结果跟上面是一样的，所以对于hmac加密只要找到key就可以了</p><p><img src="https://s2.loli.net/2022/02/11/b7fc89HmtqTveKh.png" alt="Untitled"></p><p>HMAC算法内部对key进行了异或之类的处理，处理之后的值再进行md5_update，也就是说HMAC算法不是仅仅进行了md5_update盐字符串拼接源字符串再进行哈希，还会对md5_update盐字符串进行处理，然后再拼接源字符串，最后进行哈希</p><h2 id="魔改异或值HMAC算法还原"><a href="#魔改异或值HMAC算法还原" class="headerlink" title="魔改异或值HMAC算法还原"></a>魔改异或值HMAC算法还原</h2><p>hook sub_1470c，可以看到key，不过通过HMAC算法对源字符串进行加密得出的结果跟最终加密的结果不一致，说明算法进行了魔改，最终的加密结果放在最后一个参数中了</p><p><img src="https://s2.loli.net/2022/02/11/Sw2gHYCRkz6AyF8.png" alt="Untitled"></p><p>对着参数按x，找到所有引用</p><p><img src="https://s2.loli.net/2022/02/11/Xa5CxySQc1O7NFu.png" alt="Untitled"></p><p>先进入sub_11DF0查看，根据内部的特征很有可能就是md5_transform</p><p><img src="https://s2.loli.net/2022/02/11/k3uYtUeOKPZpQDl.png" alt="Untitled"></p><p>它的上层函数就是md5_update</p><p><img src="https://s2.loli.net/2022/02/11/hjdm2PACRZgXws7.png" alt="Untitled"></p><p>hook md5_update</p><p><img src="https://s2.loli.net/2022/02/11/qRZMGh8F3u4UYkP.png" alt="Untitled"></p><p>可以看到md5_update的参数如下</p><p><img src="https://s2.loli.net/2022/02/11/xeodSYA7OwpL4Ur.png" alt="Untitled"></p><p>没有进行魔改的HMAC算法md5_udpate的参数是这样的，有大量的0x36</p><p><img src="https://s2.loli.net/2022/02/11/jtWeMVHB87pnfSq.png" alt="Untitled"></p><p>可以看到算法内部跟0x36异或的操作</p><p><img src="https://s2.loli.net/2022/02/11/ey4TJPqNOKBGh3X.png" alt="Untitled"></p><p>跟0x36异或算出来的结果就是Key</p><p><img src="https://s2.loli.net/2022/02/11/xIGlQucy3fOwKg4.png" alt="Untitled"></p><p>所以这个魔改的算法，修改了异或的值，把它跟0x88进行异或可以还原key</p><p><img src="https://s2.loli.net/2022/02/11/hUINW4fcgqteES3.png" alt="Untitled"></p><p>进行算法还原也很容易，找到HMAC的实现代码，把异或的值修改一下就可以了 </p><h2 id="HMAC-SHA256算法还原"><a href="#HMAC-SHA256算法还原" class="headerlink" title="HMAC-SHA256算法还原"></a>HMAC-SHA256算法还原</h2><p>sub_14D68函数的参数传递了一个缓冲区</p><p><img src="https://s2.loli.net/2022/02/11/rBd2RSuxLQ6kbz7.png" alt="Untitled"></p><p>打印看一下发现是kanxue_imgyang_52，因此这个函数应该就是核心算法函数 </p><p><img src="https://s2.loli.net/2022/02/11/HQufiqovYgS1ZJF.png" alt="Untitled"></p><p>进入函数因为有混淆，所以跟踪第一个参数的调用情况，然后找到了一些常量，google后确认是sha256</p><p><img src="https://s2.loli.net/2022/02/11/RdUceilgrypYk24.png" alt="Untitled"></p><p>根据源码可以确认sub_15194就是sha256_init函数</p><p><img src="https://s2.loli.net/2022/02/11/VHYv5wQW6muOlLB.png" alt="Untitled"></p><p>回到上一层，可以确认sha256_init的参数来自于sub_15148的参数 </p><p><img src="https://s2.loli.net/2022/02/11/hWMcSfZFIGdK7Dq.png" alt="Untitled"></p><p>最终可以确认sub_14d68的第一个参数是sha256_ctx</p><p><img src="https://s2.loli.net/2022/02/11/NTFQOXquaADWhKl.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/cw6SloTr4KIG7py.png" alt="Untitled"></p><p>接着分析sub_9598，在里面找到常量，google一番找到标准算法搜索后看到是数组k里面的元素</p><p><img src="https://s2.loli.net/2022/02/11/3Lv6H5VowycksKx.png" alt="Untitled"></p><p>看到k在sha256_transform内部进行了引用 </p><p><img src="https://s2.loli.net/2022/02/11/1raQMfqB5d7pAEk.png" alt="Untitled"></p><p>因此这个函数就是sha256_transform</p><p><img src="https://s2.loli.net/2022/02/11/mpORoeUc4dy7l3X.png" alt="Untitled"></p><p>查源码sha256_transform的上一层是sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/5yIsP34EvOeNJxH.png" alt="Untitled"></p><p>因此sub_9598的内部调用的是sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/uSXTOJ1kLChsxQV.png" alt="Untitled"></p><p>对sha256_update进行hook</p><p><img src="https://s2.loli.net/2022/02/11/NQPO5ozZBLxgfeu.png" alt="Untitled"></p><p>对sub_15030进行hook</p><p><img src="https://s2.loli.net/2022/02/11/tBclgqS3WjZI58M.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/6Hex9YQtTS3UuFa.png" alt="Untitled"></p><p>可以通过打印参数获取地址，可以分辨是不是同一个sha256_update</p><p><img src="https://s2.loli.net/2022/02/11/XM1zP85dsq9KCGp.png" alt="Untitled"></p><p>两个md5_update拼接生成3b999….</p><p><img src="https://s2.loli.net/2022/02/11/seSVZGIfkvmhObn.png" alt="Untitled"></p><p>再两次md5_update拼接生成最终加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/clpKr4tzX8Af2WZ.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/yPV9zpWo54CvwDF.png" alt="Untitled"></p><p>7=2$…字符串是key跟0x5c异或的结果，通过跟0x5c异或可以还原key</p><p><img src="https://s2.loli.net/2022/02/11/ydLZEYqSHkrw79t.png" alt="Untitled"></p><p>通过key生成加密字符串</p><p><img src="https://s2.loli.net/2022/02/11/1o9CqjtmZRIOYEH.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HMAC算法逆向与还原&quot;&gt;&lt;a href=&quot;#HMAC算法逆向与还原&quot; class=&quot;headerlink&quot; title=&quot;HMAC算法逆向与还原&quot;&gt;&lt;/a&gt;HMAC算法逆向与还原&lt;/h1&gt;&lt;h2 id=&quot;HMAC算法还原&quot;&gt;&lt;a href=&quot;#HMAC算法还原&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@SHA1算法逆向与还原</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@SHA1%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@SHA1%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/</id>
    <published>2022-02-11T06:51:37.000Z</published>
    <updated>2022-02-11T06:51:30.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SHA1算法逆向与还原"><a href="#SHA1算法逆向与还原" class="headerlink" title="SHA1算法逆向与还原"></a>SHA1算法逆向与还原</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>sha1算法加密后的字符串长度是40位，sha256长度是64位</p><h2 id="一般sha1算法还原"><a href="#一般sha1算法还原" class="headerlink" title="一般sha1算法还原"></a>一般sha1算法还原</h2><p>目标程序加密结果跟SHA1算法对不上</p><p><img src="https://s2.loli.net/2022/02/11/Lg8UjlFRhq2X4GE.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/mMAb8kfg1hQFePI.png" alt="Untitled"></p><p>看下伪代码，SHA1算法跟MD5是类似的，也会用调用SHA1Update函数  </p><p><img src="https://s2.loli.net/2022/02/11/GOk1WbZ6itMNxhm.png" alt="Untitled"></p><p>把盐字符串拼接上就对了</p><p><img src="https://s2.loli.net/2022/02/11/MlmW4afo79H2Jp3.png" alt="Untitled"></p><h2 id="SHA1Init常量变形还原"><a href="#SHA1Init常量变形还原" class="headerlink" title="SHA1Init常量变形还原"></a>SHA1Init常量变形还原</h2><p>运行目标程序，发现加密跟标准sha1对不上</p><p><img src="https://s2.loli.net/2022/02/11/7SdH6eTbUVpD2Er.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/PBh4l57VRfKEISz.png" alt="Untitled"></p><p>看下伪代码，发现SHA1Init函数中的常量跟标准SHA1算法不一样了，把标准SHA1算法代码中的常量替换成目标程序中的SHA1常量进行还原</p><p><img src="https://s2.loli.net/2022/02/11/usIrEDJkvlQHoCp.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/OrZhUpVjyRD2lGw.png" alt="Untitled"></p><p>把开源的sha1源码拷贝到Clion，把常量修改一下进行调用就可以实现算法还原工具了</p><p><img src="https://s2.loli.net/2022/02/11/beXuR6lZ95afTY3.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/ZnMyHhiwK3AFatk.png" alt="Untitled"></p><h2 id="SHA1Transform变形还原"><a href="#SHA1Transform变形还原" class="headerlink" title="SHA1Transform变形还原"></a>SHA1Transform变形还原</h2><p>逆向SHA1Init里的常量保存一致，SHA1Update的盐字符串也一致，结果却不一样，可以考虑是SHA1Transform函数的常量值被替换了</p><p>SHA1Transform是SHA1Update函数内部的一个函数，里面有很多常量参与运算，找出所有的常量再在标准算法里比对（也可以通过脚本进行筛查）</p><p>SHA1算法里的k1-k4就是transform里面的几个常量</p><p><img src="https://s2.loli.net/2022/02/11/fxPoqDUZE8dSls6.png" alt="Untitled"></p><p>如果有不一致的地方修改回来，再编写算法还原工具</p><h2 id="SHA1Update字符串OLLVM混淆"><a href="#SHA1Update字符串OLLVM混淆" class="headerlink" title="SHA1Update字符串OLLVM混淆"></a>SHA1Update字符串OLLVM混淆</h2><p>可以看到这里字符串变成一个变量了</p><p><img src="https://s2.loli.net/2022/02/11/t5gJAh38wxTWC9N.png" alt="Untitled"></p><p>查看这几个变量的交叉引用会跟踪到非常复杂的混淆</p><p><img src="https://s2.loli.net/2022/02/11/GxM2ZbIzWTUlK5X.png" alt="Untitled"></p><p>对于这种情况可以通过frida hook这个变量地址直接打印出字符串再代入到算法工具中进行算法还原</p><p><img src="SHA1%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F%20318b528f70494ee78f6f5c4b63619467/Untitled%2013.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SHA1算法逆向与还原&quot;&gt;&lt;a href=&quot;#SHA1算法逆向与还原&quot; class=&quot;headerlink&quot; title=&quot;SHA1算法逆向与还原&quot;&gt;&lt;/a&gt;SHA1算法逆向与还原&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ollvm@pass开发</title>
    <link href="https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%BC%80%E5%8F%91/"/>
    <id>https://tutucoo.github.io/2022/02/11/ollvm@pass%E5%BC%80%E5%8F%91/</id>
    <published>2022-02-11T06:51:37.000Z</published>
    <updated>2022-02-11T07:24:23.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pass开发"><a href="#pass开发" class="headerlink" title="pass开发"></a>pass开发</h1><h2 id="在llvm源码之外开发pass"><a href="#在llvm源码之外开发pass" class="headerlink" title="在llvm源码之外开发pass"></a>在llvm源码之外开发pass</h2><p>创建下面几个文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211H0mGNS.png" alt="Untitled"></p><p>根目录下的CMakeLists.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211PG01ap.png" alt="Untitled"></p><p>EncodeFuctionName目录下的CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211G6hiA7.png" alt="Untitled"></p><p>然后用CLion打开，有报错，解决报错</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211qwg45s.png" alt="Untitled"></p><p>修改根目录下CMakeLists.txt</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211QnFj3W.png" alt="Untitled"></p><p>还缺这两个文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211J2nV4H.png" alt="Untitled"></p><p>llvm编译目录下进行搜索找到这两个文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211MDJwlf.png" alt="Untitled"></p><p>获取完整路径 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211wGNg87.png" alt="Untitled"></p><p>设置llvm目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211dYhlQ3.png" alt="Untitled"></p><p>再声明子目录</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202113viXB2.png" alt="Untitled"></p><p>如果重名报错修改一下文件夹名称就可以了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211lbu08J.png" alt="Untitled"></p><p>这里添加一个release就可以编译一个release版本</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111jM2ro.png" alt="Untitled"></p><p>编译好之后会生成LLVMEncodeFunctionname2.so文件，使用opt指令就可以进行使用了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Jfrl48.png" alt="Untitled"></p><h2 id="注册pass"><a href="#注册pass" class="headerlink" title="注册pass"></a>注册pass</h2><p>每次加载pass要指定绝对路径还是比较麻烦的，可以通过注册pass，这样就不用每次指定绝对路径</p><p>找到include目录 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211ez0Cpo.png" alt="Untitled"></p><p>创建一个头文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211x8zKnx.png" alt="Untitled"></p><p>创建一个接口</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/2022021105Iwac.png" alt="Untitled"></p><p>包含头文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211jLkgG5.png" alt="Untitled"></p><p>在EncodeFunctionName.cpp实现该接口</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hA9Jui.png" alt="Untitled"></p><p>添加一些实现</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gmCZYu.png" alt="Untitled"></p><p>判断一下</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211WPKlkD.png" alt="Untitled"></p><p>找到PassManagerBuilder.cpp添加EncodeFunctionName.h头文件 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211R9qBBu.png" alt="Untitled"></p><p>在CMakeLists.txt中添加下面的指令以便编译成静态库</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211e8qksM.png" alt="Untitled"></p><p>在llvm/lib/Transforms/LLVMBuild.txt中添加到common中</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211QEuDMr.png" alt="Untitled"></p><p>llvm/lib/Transforms/IPO/LLVMBuild.txt中也要添加</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202118icuDM.png" alt="Untitled"></p><p>创建LLVMBuild.txt文件</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211gzStrj.png" alt="Untitled"></p><p>添加参数</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211hiIyhW.png" alt="Untitled"></p><p>还是在PassManagerBuilder.cpp中添加代码，如果命令执行时有参数就会执行这个pass</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211Uodg9n.png" alt="Untitled"></p><p>然后执行ninja LLVMEncodeFunctionName单独进行编译</p><p>再编译clang工具 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211rlLL9G.png" alt="Untitled"></p><p>这时就可以把自定义的pass当作参数传递进去进行编译了</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211VXO978.png" alt="Untitled"></p><h2 id="在llvm源码外调试pass"><a href="#在llvm源码外调试pass" class="headerlink" title="在llvm源码外调试pass"></a>在llvm源码外调试pass</h2><p>这里路径修改为debug版本的 </p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211DAhDrB.png" alt="Untitled"></p><p>找到opt的绝对路径</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211FXKcLY.png" alt="Untitled"></p><p>在CLion中进行指定</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202115TFRTJ.png" alt="Untitled"></p><p>参数填写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-load pass绝对路径 -pass参数 ll文件绝对路径</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/202202111XiJbD.png" alt="Untitled"></p><p>然后在runOnFunction里面下断点进行调试</p><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211LqqAv5.png" alt="Untitled"></p><h2 id="clang加载pass"><a href="#clang加载pass" class="headerlink" title="clang加载pass"></a>clang加载pass</h2><p><img src="https://gitee.com/tutucoo/images/raw/master/uPic/20220211tD3Wva.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pass开发&quot;&gt;&lt;a href=&quot;#pass开发&quot; class=&quot;headerlink&quot; title=&quot;pass开发&quot;&gt;&lt;/a&gt;pass开发&lt;/h1&gt;&lt;h2 id=&quot;在llvm源码之外开发pass&quot;&gt;&lt;a href=&quot;#在llvm源码之外开发pass&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@MD5算法逆向与还原</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@MD5%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@MD5%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/</id>
    <published>2022-02-11T06:47:37.000Z</published>
    <updated>2022-02-11T06:47:51.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MD5算法逆向与还原"><a href="#MD5算法逆向与还原" class="headerlink" title="MD5算法逆向与还原"></a>MD5算法逆向与还原</h1><h2 id="算法的识别"><a href="#算法的识别" class="headerlink" title="算法的识别"></a>算法的识别</h2><p>md5算法很好识别，一般会先调用MD5Init，然后调用MD5Update，最后调用MD5Final，这里多次调用md5update，实际上完成的是字符串的加盐</p><p>如果不是很确定，可以先google搜索MD5Init那里的常量，一般可以搜索到算法</p><p><img src="https://s2.loli.net/2022/02/11/P7VRm2bgYkOeiQH.png" alt="Untitled"></p><h2 id="MD5算法还原"><a href="#MD5算法还原" class="headerlink" title="MD5算法还原"></a>MD5算法还原</h2><p>google搜md5.c，找到MD5的实现，编写算法还原工具，需要注意MD5Init的常量需要逆向获得</p><h2 id="混淆的MD5算法还原"><a href="#混淆的MD5算法还原" class="headerlink" title="混淆的MD5算法还原"></a>混淆的MD5算法还原</h2><p>对于混淆的算法，直接硬看一般什么也看不出来，不过可以通过参数引用来进行逆向分析</p><p>这个jni函数只有一个参数，类型是一个字符串，源字符串通过这个参数传递进来，我们把它重命名为input</p><p><img src="https://s2.loli.net/2022/02/11/SoYUZGWs7dckjLX.png" alt="Untitled"></p><p>查看它的交叉引用</p><p><img src="https://s2.loli.net/2022/02/11/PUIgjzAxS4pJGyt.png" alt="Untitled"></p><p>查看第一处input引用，通过v15传参，接着可以分析v15的引用情况，同时发现v15返回值是s，返回值也要关注，这里sub_F794传递了v15和s，所以可以通过frida hook并用hexdump观察内存中的字节码进行分析</p><p><img src="https://s2.loli.net/2022/02/11/ubFiv6GrXlHpRYc.png" alt="Untitled"></p><p>最终定位到关键函数，再找到MD5Update的位置，hook参数，查看这些参数字符串，将这些参数字符串拼接代入到md5算法中如果结果一致就可以编写还原工具了</p><p><img src="https://s2.loli.net/2022/02/11/ANbr6P4xtyG3Lip.png" alt="Untitled"></p><h2 id="深度修改MD5算法还原"><a href="#深度修改MD5算法还原" class="headerlink" title="深度修改MD5算法还原"></a>深度修改MD5算法还原</h2><p>有些MD5算法即使hook到MD5Update传递的加盐字符串，算出的结果仍然不一致，这种情况就很有可能是动了md5的transform</p><p><img src="https://s2.loli.net/2022/02/11/HIPoiG5WbJNsBAp.png" alt="Untitled"></p><p>transform函数里面非常复杂，也有非常多的常量，可以在google搜索到包含这些常量的源文件，然后找到这些常量</p><p><img src="https://s2.loli.net/2022/02/11/eomnxTwAyXf9Cig.png" alt="Untitled"></p><p>接着通过动态trace指令，把目标函数所有指令trace下来，里面必然包含了这些常量，最后写脚本比对不存在的常量，那么不存在的常量就是被修改的，在trace文件中找到被修改的常量，然后patch md5算法，就可以实现算法还原工具了 </p><p><img src="https://s2.loli.net/2022/02/11/oYV9NsnSEkh5rLd.png" alt="Untitled"></p><p>这里缺少的常量是下面两个</p><p><img src="https://s2.loli.net/2022/02/11/aAdrLZD9qkcUO1f.png" alt="Untitled"></p><p>缺少的常量在代码中的位置 </p><p><img src="https://s2.loli.net/2022/02/11/YxT4iBVlfaqs8Hk.png" alt="Untitled"></p><p>可以先找到在它前面的常量0xfd469501，+CCC地址是处理这个常量的地址，执行到这里时x10里面保存的值是0xfd469501</p><p><img src="https://s2.loli.net/2022/02/11/uHqs8X3d4CZ7Umi.png" alt="Untitled"></p><p>在ida中定位到位置</p><p><img src="https://s2.loli.net/2022/02/11/hrOW1zMovw2gibe.png" alt="Untitled"></p><p><img src="https://s2.loli.net/2022/02/11/3lufRvB2jkOp8tG.png" alt="Untitled"></p><p>4249261313转换为16进制就是常量0xfd469501</p><p><img src="https://s2.loli.net/2022/02/11/VpAR3uHM5S2Pw6f.png" alt="Untitled"></p><p>那么它的下一个常量可能就是修改过的常量了</p><p><img src="https://s2.loli.net/2022/02/11/k9QYq8ZmBjhsGlp.png" alt="Untitled"></p><p>但是在trace文件中找不到这个值，也就是说上图中的值应该不是</p><p>按tab找到在汇编中的位置，因为源码中对这些常量用的是加法，所以这里看到ADD就可以在trace文件中搜索c428</p><p><img src="https://s2.loli.net/2022/02/11/9Rfc6D53oJuadhm.png" alt="Untitled"></p><p>在trace文件中找到了这个位置，根据之前常量所在位置可以确定这个值是0x699880d8，缺失的值修改为它就可以了</p><p><img src="https://s2.loli.net/2022/02/11/4DUCcVWq8tp56Gw.png" alt="Untitled"></p><p>继续找另一个缺失的常量0xc33707d6，同样的先定位它前面的常量0x21e1cde6</p><p><img src="https://s2.loli.net/2022/02/11/kTw7xQAN95s4Cjg.png" alt="Untitled"></p><p>在0x21e1cde6和0xf4d50d87之间找了所有add附近的常量都不太像，最后在0x21e1cde6前面的位置找到了，它的值是0xc30737d6，缺失的另一值也找到了，可见在指令执行时位置不绝对按照源码中的顺序来执行的</p><p><img src="https://s2.loli.net/2022/02/11/IZj8S95HPUeuiLY.png" alt="Untitled"></p><p>最后把这两个改变的常量代入到md5算法工具代码中使用，计算出的结果一致了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MD5算法逆向与还原&quot;&gt;&lt;a href=&quot;#MD5算法逆向与还原&quot; class=&quot;headerlink&quot; title=&quot;MD5算法逆向与还原&quot;&gt;&lt;/a&gt;MD5算法逆向与还原&lt;/h1&gt;&lt;h2 id=&quot;算法的识别&quot;&gt;&lt;a href=&quot;#算法的识别&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@CRC32算法逆向与还原</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@CRC32%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@CRC32%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E4%B8%8E%E8%BF%98%E5%8E%9F/</id>
    <published>2022-02-11T06:42:37.000Z</published>
    <updated>2022-02-11T06:43:51.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRC32算法逆向与还原"><a href="#CRC32算法逆向与还原" class="headerlink" title="CRC32算法逆向与还原"></a>CRC32算法逆向与还原</h1><h2 id="算法的识别"><a href="#算法的识别" class="headerlink" title="算法的识别"></a>算法的识别</h2><p>经过CRC32加密的密文通常是4个字节长度，可以通过IDA逆向确定它是CRC32算法，方法是找到算法中的常量，通过google搜索会出现CRC32算法相关的搜索结果从而确定它是CRC32算法，下图中的常量0xEDB88320，经过google搜索发现它是CRC32算法 </p><p><img src="https://s2.loli.net/2022/02/11/rWyojAlTKO9qLIu.png" alt="Untitled"></p><h2 id="算法逆向"><a href="#算法逆向" class="headerlink" title="算法逆向"></a>算法逆向</h2><p>逆向目标so，找到CRC32核心算法，CRC32核心算法非常简短，对于这一类算法直接拷贝到clion，进行运行，报错的地方进行修正，直接完成算法还原工具</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> is_init = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> crc32_table[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crc_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// r0</span></span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// r3</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// r4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// r5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = <span class="number">8</span>;</span><br><span class="line">        v2 = i;</span><br><span class="line">        <span class="keyword">while</span> ( v1 )</span><br><span class="line">        &#123;</span><br><span class="line">            v3 = (v2 &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88310</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !(v2 &lt;&lt; <span class="number">31</span>) )</span><br><span class="line">                v3 = v2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            --v1;</span><br><span class="line">            v2 = v3;</span><br><span class="line">        &#125;</span><br><span class="line">        crc32_table[i] = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    is_init = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crc32</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">char</span> *a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *v5; <span class="comment">// r5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">int</span> v13; <span class="comment">// r2</span></span><br><span class="line">    <span class="keyword">int</span> v14; <span class="comment">// r3</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v15; <span class="comment">// r1</span></span><br><span class="line">    <span class="keyword">int</span> v16; <span class="comment">// r2</span></span><br><span class="line">    <span class="keyword">int</span> v17; <span class="comment">// r3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v5 = a2;</span><br><span class="line">    <span class="keyword">if</span> (!is_init)</span><br><span class="line"></span><br><span class="line">        crc_init();</span><br><span class="line"></span><br><span class="line">    v6 = ~a1;</span><br><span class="line">    <span class="keyword">while</span> (a3 &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        a3 -= <span class="number">8</span>;</span><br><span class="line">        v7 = crc32_table[*v5 ^ (<span class="keyword">unsigned</span> <span class="keyword">char</span>)v6] ^(v6 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v8 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)v7 ^ v5[<span class="number">1</span>]] ^(v7 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v9 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)v8 ^ v5[<span class="number">2</span>]] ^(v8 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v10 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)v9 ^ v5[<span class="number">3</span>]] ^(v9 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v11 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)v10 ^ v5[<span class="number">4</span>]] ^(v10 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v12 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)v11 ^ v5[<span class="number">5</span>]] ^ (v11 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v13 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)v12 ^ v5[<span class="number">6</span>];</span><br><span class="line">        v14 = v5[<span class="number">7</span>];</span><br><span class="line">        v5 += <span class="number">8</span>;</span><br><span class="line">        v15 = crc32_table[v13] ^ (v12 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        v6 = crc32_table[(<span class="keyword">unsigned</span> <span class="keyword">char</span> )v15 ^ v14] ^ (v15 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a3) &#123;</span><br><span class="line">        v16 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v17 = v5[v16++];</span><br><span class="line">            v6 = crc32_table</span><br><span class="line">                 [v17 ^ (<span class="keyword">unsigned</span> <span class="keyword">char</span> ) v6] ^ (v6 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (a3 != v16);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~v6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;kZPpcuZDGquGjAljnCVaq&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ret = crc32(<span class="number">0</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) str.data(), str.size());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/11/oBETJudfrpChAnH.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRC32算法逆向与还原&quot;&gt;&lt;a href=&quot;#CRC32算法逆向与还原&quot; class=&quot;headerlink&quot; title=&quot;CRC32算法逆向与还原&quot;&gt;&lt;/a&gt;CRC32算法逆向与还原&lt;/h1&gt;&lt;h2 id=&quot;算法的识别&quot;&gt;&lt;a href=&quot;#算法的识别&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法@base64算法</title>
    <link href="https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@base64%E7%AE%97%E6%B3%95/"/>
    <id>https://tutucoo.github.io/2022/02/11/%E7%AE%97%E6%B3%95@base64%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-11T06:36:41.000Z</published>
    <updated>2022-02-11T06:38:29.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="base64算法"><a href="#base64算法" class="headerlink" title="base64算法"></a>base64算法</h1><p>下图是对字符串“BC”进行base64编码 </p><p>首先对BC进行二进制分解，分解为8位2进制，接着每6位2进制分为一组，末尾不足的位补0，最后按照ASCII编码表还原字符串，按照6位一组，最少4组，不足的用=号补位</p><p><img src="https://s2.loli.net/2022/02/11/LdSv3RN6GJ7scEZ.png" alt="Untitled"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;base64算法&quot;&gt;&lt;a href=&quot;#base64算法&quot; class=&quot;headerlink&quot; title=&quot;base64算法&quot;&gt;&lt;/a&gt;base64算法&lt;/h1&gt;&lt;p&gt;下图是对字符串“BC”进行base64编码 &lt;/p&gt;
&lt;p&gt;首先对BC进行二进制分解，分解为</summary>
      
    
    
    
    
  </entry>
  
</feed>
